<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/Objective-C-9/"/>
    <url>/2022/07/05/Objective-C-9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/Objective-C-8/"/>
    <url>/2022/07/05/Objective-C-8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/Objective-C-7-IOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-MRC/"/>
    <url>/2022/07/05/Objective-C-7-IOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-MRC/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-5-语言特性-万能类型</title>
    <link href="/2022/07/05/Objective-C-5-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E4%B8%87%E8%83%BD%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/07/05/Objective-C-5-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E4%B8%87%E8%83%BD%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="OC中的数据类型有什么特点"><a href="#OC中的数据类型有什么特点" class="headerlink" title="OC中的数据类型有什么特点?"></a>OC中的数据类型有什么特点?</h1><ul><li>OC是1门弱类型语言<ul><li>编译器在编译的时候.语法检查的时候没有那么严格.</li><li>强类型的语言: 编译器在编译的时候 做语法检查的时候 必须类型一致</li></ul></li><li>静态类型:指针指向的对象是1个本类对象</li><li>动态类型:指针指向的对象不是本类对象</li></ul><h1 id="OC中的编译检查和运行检查是什么"><a href="#OC中的编译检查和运行检查是什么" class="headerlink" title="OC中的编译检查和运行检查是什么?"></a>OC中的编译检查和运行检查是什么?</h1><ul><li><p>编译器在编译的时候,判断1个指针能否调用其指向的对象的方法,这一操作被称为编译检查</p><ul><li>如果<strong>指针所属的类型</strong>中存在对应方法,编译通过</li><li>如果<strong>指针所属的类型</strong>中不存在对应方法,编译报错</li></ul></li><li><p>由于 OC 是弱类型语言,可以将指针的类型转换,使编译器不会报错</p><ul><li>但是在运行时会检查对象中是否真存在对应方法<ul><li>如果有就执行 ,没有就报错误</li></ul></li></ul></li><li><p>这两种检查方式分别被称为编译检查和运行检查</p></li></ul><h1 id="LSP-里氏置换原则"><a href="#LSP-里氏置换原则" class="headerlink" title="LSP:里氏置换原则"></a>LSP:里氏置换原则</h1><ul><li>父类指针指向子类对象<ul><li>这种情况下子类对象是父类的实际实现,从面向对象的思想来看,是一种细化的过程,所以编译器不会报错</li><li>实际上在 OC 中,任意的指针可以执行任意的对象.编译器都不会报错</li></ul></li><li>注意:子类指针可以存储父类对象,但无法调用子类中的有的属性以及方法</li></ul><h1 id="OC-中的-NSObject-类"><a href="#OC-中的-NSObject-类" class="headerlink" title="OC 中的 NSObject 类"></a>OC 中的 NSObject 类</h1><ul><li><p>是OC中所有类的基类</p></li><li><p>根据LSP里氏替换原则, NSObject类型的指针可以指向任意一个OC对象.</p></li><li><p>从这一角度来看, NSObject类型的指针是1种万能指针,可以执行任意的OC对象.</p></li><li><p>但如果要调用对应子类对象的独有方法时,必须要做类型转换</p></li></ul><h1 id="id指针-–真正的万能类型"><a href="#id指针-–真正的万能类型" class="headerlink" title="id指针 –真正的万能类型"></a>id指针 –真正的万能类型</h1><ul><li><p>是1个万能指针,可以指向任意的OC对象.</p></li><li><p>id是1个typedef自定义类型 在定义的时候已经加了*,声明id指针的时候不需要再加*了.</p></li></ul><p>![截屏2022-07-05 21.03.05](.&#x2F;Objective-C-5-语言特性-万能类型.assets&#x2F;截屏2022-07-05 21.03.05-7026201.png)</p><h1 id="NSObject指针和id指针的异同"><a href="#NSObject指针和id指针的异同" class="headerlink" title="NSObject指针和id指针的异同"></a>NSObject指针和id指针的异同</h1><ul><li><p>相同点: </p><ul><li>万能指针 都可以存储任意的OC对象</li></ul></li><li><p>不同点: </p><ul><li>NSObject指针 调用对象的方法时 编译器会做编译检查.</li><li>id类型的指针 调用对象的方法时 编译器直接通过.无论你调用什么方法.</li></ul></li><li><p>注意:</p><ul><li>id指针只能调用对象的方法 不能使用点语法.如果使用点语法就会直接报编译错误</li><li>声明1个万能指针时 应该使用 id</li></ul></li></ul><h1 id="id-指针的其他应用"><a href="#id-指针的其他应用" class="headerlink" title="id 指针的其他应用:"></a>id 指针的其他应用:</h1><h2 id="父类中的类方法-返回一个父类对象-此方法需要子类进行调用"><a href="#父类中的类方法-返回一个父类对象-此方法需要子类进行调用" class="headerlink" title="父类中的类方法,返回一个父类对象,此方法需要子类进行调用"></a>父类中的类方法,返回一个父类对象,此方法需要子类进行调用</h2><ul><li>子类不能存储父类对象,如果返回值写为父类类型的.那么子类来调用这个方法得到的就是父类指针.<ul><li>可以把返回值改为id类型,但此时任意指针都可以接收这个方法的返回值,且编译器不会发出警告</li><li>此时可以使用instancetype</li><li>注意:<ul><li>方法的内部创建的对象时一般不要写死;因为写死创建的对象就固定了</li></ul></li></ul></li></ul><h2 id="任意类来调用某方法就创建那个类的对象"><a href="#任意类来调用某方法就创建那个类的对象" class="headerlink" title="任意类来调用某方法就创建那个类的对象"></a>任意类来调用某方法就创建那个类的对象</h2><ul><li>通过 [self new] 方式创建本类对象</li><li>返回值 不使用 id 而是用 instancetype</li></ul><h1 id="id和instancetype的区别"><a href="#id和instancetype的区别" class="headerlink" title="id和instancetype的区别"></a>id和instancetype的区别</h1><ul><li><p>不同点:</p><ul><li><p>instancetype只能作为方法的返回值.不能在别的地方使用.</p></li><li><p>instancetype 是1个有类型的 代表当前类的对象.</p></li><li><p>id既可以声明指针变量 也可以作为参数 也可以作为返回值.</p></li><li><p>id是1个无类型的指针 仅仅是1个地址.没有类型的指针.</p></li></ul></li></ul><h1 id="编译检查中可以使用哪些操作"><a href="#编译检查中可以使用哪些操作" class="headerlink" title="编译检查中可以使用哪些操作?"></a>编译检查中可以使用哪些操作?</h1><h2 id="判断对象中是否有这个方法可以执行"><a href="#判断对象中是否有这个方法可以执行" class="headerlink" title="判断对象中是否有这个方法可以执行."></a>判断对象中是否有这个方法可以执行.</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>respondsToSelector:<span class="hljs-params">(SEL)</span>aSelector;<br></code></pre></td></tr></table></figure><h2 id="判断类中是否有指定的类方法"><a href="#判断类中是否有指定的类方法" class="headerlink" title="判断类中是否有指定的类方法."></a>判断类中是否有指定的类方法.</h2>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">+ (BOOL)instancesRespondToSelector:(SEL)aSelector;<br></code></pre></td></tr></table></figure><h2 id="判断指定的对象是否为-指定类的对象或者子类对象"><a href="#判断指定的对象是否为-指定类的对象或者子类对象" class="headerlink" title="判断指定的对象是否为 指定类的对象或者子类对象."></a>判断指定的对象是否为 指定类的对象或者子类对象.</h2>  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>isKindOfClass:<span class="hljs-params">(Class)</span>aClass;<br></code></pre></td></tr></table></figure><h2 id="判断对象是否为指定类的对象-不包括子类"><a href="#判断对象是否为指定类的对象-不包括子类" class="headerlink" title="判断对象是否为指定类的对象 不包括子类."></a>判断对象是否为指定类的对象 不包括子类.</h2>  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>isMemberOfClass:<span class="hljs-params">(Class)</span>aClass;<br></code></pre></td></tr></table></figure><h2 id="判断类是否为另外1个类的子类"><a href="#判断类是否为另外1个类的子类" class="headerlink" title="判断类是否为另外1个类的子类."></a>判断类是否为另外1个类的子类.</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">+ <span class="hljs-comment">(BOOL)</span>isSubclassOfClass:<span class="hljs-comment">(Class)</span>aClass;<br></code></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-3-语言特性-SEL消息</title>
    <link href="/2022/07/04/Objective-C-3-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-SEL%E6%B6%88%E6%81%AF/"/>
    <url>/2022/07/04/Objective-C-3-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-SEL%E6%B6%88%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="OC中类的实际形态是如何的？"><a href="#OC中类的实际形态是如何的？" class="headerlink" title="OC中类的实际形态是如何的？"></a>OC中类的实际形态是如何的？</h1><ul><li>类是以Class对象的形式存储在代码段之中.</li><li>OC 中，一个类 被认为是 元类的对象</li></ul><p>类名:存储的这个类的类名. NSString </p><p>方法存储在类对象之中.如何将方法存储在类对象之中.</p><h1 id="OC中的SEL是什么？"><a href="#OC中的SEL是什么？" class="headerlink" title="OC中的SEL是什么？"></a>OC中的SEL是什么？</h1><ul><li>叫做 selector 选择器</li><li>是一种变量类型，所以要在内存中申请空间存储数据.</li><li>转定义后，SEL本质是1个结构体. </li><li><strong>SEL结构体变量用于存储消息.类似于函数指针</strong><ul><li>消息类似于方法，OC中调用方法一般被称为发送消息</li></ul></li><li>使用SEL对象类发送消息 使编译器不会验证这个方法是否声明，直接向对象发送消息</li><li>一般作为Class对象 的属性，用于将类方法存储到 Class对象 中</li></ul><h1 id="SEL应如何使用？"><a href="#SEL应如何使用？" class="headerlink" title="SEL应如何使用？"></a>SEL应如何使用？</h1><ul><li>创建1个SEL对象，将方法的信息存储在这个SEL对象之中.</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SEL</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-meta">@selector(方法名)</span>;<br></code></pre></td></tr></table></figure><ul><li>SEL使用时不需要加*</li></ul><p><img src="/./Objective-C-3-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-SEL%E6%B6%88%E6%81%AF/1.png" alt="image-20220703122856297"></p><h1 id="OC中调用方法的内部原理是怎样的？"><a href="#OC中调用方法的内部原理是怎样的？" class="headerlink" title="OC中调用方法的内部原理是怎样的？"></a>OC中调用方法的内部原理是怎样的？</h1><ul><li><p>现有这样一个方法，p1是Person类的对象，sayHi是其实例方法</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[p1 sayHi]</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><ol><li>获取到 sayHi 这一消息的 SEL 对象</li><li>将这个SEL消息发送给p1对象，此时，p1对象接收到这个SEL消息以后 就知道要调用方法</li><li>根据p1对象的isa指针寻找存储类Person（Class对象）</li><li>找到这个类（Class对象）以后 在其中去搜寻是否有和传入的SEL数据相匹配的方法</li><li>如果有 就执行  如果没有再向父类寻找 直到NSObject类，若都没有匹配的方法，则抛出异常</li></ol><h1 id="OC的重要机制-消息机制"><a href="#OC的重要机制-消息机制" class="headerlink" title="OC的重要机制:消息机制"></a>OC的重要机制:消息机制</h1><ul><li>调用方法的本质其实就是向对象发送SEL消息.</li><li>[p1 sayHi]; 向p1对象发送1条sayHi消息.</li><li>重点掌握:<br>1).方法是以SEL对象的形式存储起来.<br>2).如何拿到存储方法的SEL对象：Class 对象获取</li></ul><h1 id="SEL消息的其他用法？"><a href="#SEL消息的其他用法？" class="headerlink" title="SEL消息的其他用法？"></a>SEL消息的其他用法？</h1><h2 id="手动发送消息"><a href="#手动发送消息" class="headerlink" title="手动发送消息"></a>手动发送消息</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">调用对象的方法 将SEL数据发送给对象.<br>- <span class="hljs-params">(id)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Person *p1 = [Person <span class="hljs-keyword">new</span>];<br><span class="hljs-type">SEL</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-meta">@selector(sayHi)</span>; <span class="hljs-comment">//先得到方法的SEL数据.</span><br>[p1 performSelector:s1];  <span class="hljs-comment">// 将这个SEL消息发送给p1对象，与 [p1 sayHi]效果是完全一样的.</span><br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h1><ol><li>使用 SEL 对象时，如果方法有参数 那么方法名是带了冒号的 <ol><li>@selector(sayHi:);</li></ol></li><li>如果方法有参数就调用如下方法:</li></ol><ul><li>(id)performSelector:(SEL)aSelector withObject:(id)object;</li><li>(id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</li></ul><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol><li><p>类是以Class对象的形式存储在代码段.</p></li><li><p>如何取到存储类的类对象.</p></li><li><p>如何使用类对象调用类的类方法 </p></li><li><p>方法是以SEL数据的形式存储的.</p></li><li><p>调用方法的两种方式.</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-4-语言特性-getter-setter</title>
    <link href="/2022/07/04/Objective-C-4-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-getter-setter/"/>
    <url>/2022/07/04/Objective-C-4-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-getter-setter/</url>
    
    <content type="html"><![CDATA[<h1 id="OC中是如何访问对象的属性的"><a href="#OC中是如何访问对象的属性的" class="headerlink" title="OC中是如何访问对象的属性的?"></a>OC中是如何访问对象的属性的?</h1><ul><li><p>OC中可以使用点语法来访问对象的属性</p></li><li><p>语法如下所示:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//对象名.去掉下划线的属性名;<br>p1.name = @&quot;jack&quot;; //这个时候就会将@&quot;jack&quot;赋值给p1对象的_name属性.<br>NSString *name = p1.name; //把p1对象的_name属性的值取出来<br></code></pre></td></tr></table></figure><ul><li>但,OC的对象如果要为属性赋值或者取值 就要调用对应的getter或者setter.</li></ul><h1 id="点语法实际是如何进行的"><a href="#点语法实际是如何进行的" class="headerlink" title="点语法实际是如何进行的?"></a>点语法实际是如何进行的?</h1>   <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">p1.age</span> = <span class="hljs-number">18</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>点语法在编译器编译的时候.会将点语法转换为调用setter、getter的代码.</li></ul><h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作:"></a>赋值操作:</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">p1.age</span> = <span class="hljs-number">10</span><span class="hljs-comment">;//对象名.去掉下划线的属性名 = 数据; 转换为</span><br><span class="hljs-section">[p1 setAge:10]</span><span class="hljs-comment">; //  [对象名 set去掉下划线的属性名首字母大写:数据];</span><br></code></pre></td></tr></table></figure><h2 id="取值操作"><a href="#取值操作" class="headerlink" title="取值操作:"></a>取值操作:</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int age <span class="hljs-operator">=</span> p1.age<span class="hljs-comment">;//     对象名.去掉下划线的属性名; 转换为</span><br>int age <span class="hljs-operator">=</span> [p1 age]<span class="hljs-comment">;//    [对象名 去掉下划线的属性名];</span><br></code></pre></td></tr></table></figure><h1 id="点语法注意"><a href="#点语法注意" class="headerlink" title="点语法注意:"></a>点语法注意:</h1><ul><li><p>在getter和setter中慎用点语法,因为有可能会造成无限递归 而程序崩溃</p></li><li><p>setter方法和getter方法名不符合规范 点语法就会出问题.</p></li><li><p>如果属性没有封装getter setter 是无法使用点语法的</p></li></ul><h1 id="property关键字是什么"><a href="#property关键字是什么" class="headerlink" title="@property关键字是什么?"></a>@property关键字是什么?</h1><ul><li><p>为了简化类属性 getter&#x2F;setter的声明代码,用于 <strong>自动生成类属性的getter、setter方法的声明</strong> 的关键字</p></li><li><p>会额外为类生成属性,并不会影响原来类已有的属性</p></li><li><p>因为是生成方法的声明,所以应该写在@interface类的声明之中.</p></li><li><p>语法: @property 数据类型 名称;</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@<span class="hljs-keyword">property</span> <span class="hljs-built_in">int</span> age; <br></code></pre></td></tr></table></figure><h1 id="property的原理是怎样的"><a href="#property的原理是怎样的" class="headerlink" title="@property的原理是怎样的?"></a>@property的原理是怎样的?</h1><ul><li>编译器在编译的时候.会根据@property生成getter和setter方法的实现</li></ul> <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@<span class="hljs-keyword">property</span> <span class="hljs-built_in">int</span> age; <span class="hljs-comment">//@property 数据类型 名称;</span><br>- (<span class="hljs-built_in">void</span>)setAge:(<span class="hljs-built_in">int</span>)age;<span class="hljs-comment">//- (void)set首字母大写的名称:(数据类型)名称;</span><br>- (<span class="hljs-built_in">int</span>)age;<span class="hljs-comment">//- (数据类型)名称;</span><br></code></pre></td></tr></table></figure><h1 id="property注意"><a href="#property注意" class="headerlink" title="@property注意:"></a>@property注意:</h1><ul><li><p><strong>@property的类型</strong>和<strong>属性的类型</strong>一致.</p></li><li><p><strong>@property的名称</strong>和<strong>属性的名称</strong>一致(去掉下划线)</p></li><li><p>@property只是生成getter和setter方法的声明. 实现还要自己来. 属性还要自己定义.</p></li></ul><h1 id="synthesize关键字是什么"><a href="#synthesize关键字是什么" class="headerlink" title="@synthesize关键字是什么?"></a>@synthesize关键字是什么?</h1><ul><li><p>为了简化类属性 getter&#x2F;setter的实现代码,用于 <strong>自动生成类的getter、setter方法的实现</strong> 的关键字</p></li><li><p>因为是生成方法的实现,所以应该写在@implement类的实现之中.</p></li><li><p>语法如下所示:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//--------Person.h<br>@interface Person : NSObject<br>&#123;<br>   int _age;<br>&#125;<br>@property int age;//age 的 getter,setter 声明<br>@end<br><br>//--------Person.m<br>@implmentation Person<br>@synthesize age; //age 的 getter,setter 实现 ;@synthesize @property名称;<br>@end<br><br><br></code></pre></td></tr></table></figure><h1 id="synthesize的原理是怎样的"><a href="#synthesize的原理是怎样的" class="headerlink" title="@synthesize的原理是怎样的?"></a>@synthesize的原理是怎样的?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@implmentation Person<br>  @synthesize age;<br>@end<br>//----------上述代码等同于如下代码:<br>@implementaion Person<br>&#123;<br>  int age;<br>&#125;<br>- (void)setAge:(int)age<br>&#123;<br>  self-&gt;age = age;<br>&#125;<br>- (int)age<br>&#123;<br>  return age;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><h1 id="synthesize做什么工作呢"><a href="#synthesize做什么工作呢" class="headerlink" title="@synthesize做什么工作呢?"></a>@synthesize做什么工作呢?</h1><h2 id="会自动生成的完全私有属性"><a href="#会自动生成的完全私有属性" class="headerlink" title="会自动生成的完全私有属性:"></a>会自动生成的完全私有属性:</h2><ul><li>如下写法会在这一类中自动生成一个完全私有的属性,以及这个属性的 getter 和 setter</li><li>自动生成的属性与外部其他属性无关</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>类的实现部分<br>@synthesize name;<span class="hljs-regexp">//</span>@synthesize 属性名称;<br></code></pre></td></tr></table></figure><ul><li>属性的类型应和@synthesize对应的@property类型或属性声明一致.</li><li>属性的名字应和@synthesize对应的@property名字或属性声明一致.</li></ul><h2 id="自动生成setter方法的实现"><a href="#自动生成setter方法的实现" class="headerlink" title="自动生成setter方法的实现:"></a>自动生成setter方法的实现:</h2><ul><li>实现的方式: 将参数直接赋值给**@synthesize自动生成的私有属性**.并且<strong>不会做任何额外操作</strong>,也不会对其他属性有影响</li></ul><h2 id="自动生成getter方法的实现"><a href="#自动生成getter方法的实现" class="headerlink" title="自动生成getter方法的实现."></a>自动生成getter方法的实现.</h2><ul><li>实现的方式: 直接将**@synthesize自动生成的私有属性的值**返回</li></ul><h1 id="如果属性被写好了-如何使用-synthesize自动生成-getter-和-setter"><a href="#如果属性被写好了-如何使用-synthesize自动生成-getter-和-setter" class="headerlink" title="如果属性被写好了,如何使用@synthesize自动生成 getter 和 setter?"></a>如果属性被写好了,如何使用@synthesize自动生成 getter 和 setter?</h1><ul><li>可以使用如下写法来实现:</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@synthesize</span> age = _age; <span class="hljs-regexp">//</span><span class="hljs-variable">@synthesize</span> 属性(<span class="hljs-variable">@property</span> 的)名称 = 已经存在的属性名;<br></code></pre></td></tr></table></figure><ul><li>这种写法的特点:<ul><li>不会再去生成私有属性.</li><li>直接生成setter getter的实现,且操作的是指定的属性</li></ul></li></ul><h1 id="如何向-synthesize自动生成的getter-和-setter中添加新逻辑"><a href="#如何向-synthesize自动生成的getter-和-setter中添加新逻辑" class="headerlink" title="如何向@synthesize自动生成的getter 和 setter中添加新逻辑?"></a>如何向@synthesize自动生成的getter 和 setter中添加新逻辑?</h1><ul><li><p>@synthesize生成的setter方法实现中 是没有做任何逻辑验证的 是直接赋值.</p></li><li><p>@synthesize生成的getter方法的实现中 是直接返回属性的值.</p></li><li><p>如果setter或者getter有自己的逻辑验证 那么就自己在类的实现中重写就可以了.</p></li></ul><h1 id="当类中有较多属性时-如何简便的向类中添加多个属性的声明及实现"><a href="#当类中有较多属性时-如何简便的向类中添加多个属性的声明及实现" class="headerlink" title="当类中有较多属性时,如何简便的向类中添加多个属性的声明及实现?"></a>当类中有较多属性时,如何简便的向类中添加多个属性的声明及实现?</h1><ul><li>@property只是生成getter setter 的声明</li><li>@synthesize是生成getter setter 的实现</li></ul><h2 id="声明多个类型一致的-property"><a href="#声明多个类型一致的-property" class="headerlink" title="声明多个类型一致的@property"></a>声明多个类型一致的@property</h2> <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@property</span> float <span class="hljs-attribute">height</span>,weight;<br></code></pre></td></tr></table></figure><h2 id="声明多个-synthesize"><a href="#声明多个-synthesize" class="headerlink" title="声明多个@synthesize"></a>声明多个@synthesize</h2><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">@synthesize <span class="hljs-built_in">name</span> = <span class="hljs-variable">_name</span>,age = <span class="hljs-variable">_age</span>,weight = <span class="hljs-variable">_weight</span>,height = <span class="hljs-variable">_height</span>;<br></code></pre></td></tr></table></figure><h1 id="新版本的-property"><a href="#新版本的-property" class="headerlink" title="新版本的@property"></a>新版本的@property</h1><ul><li>Xcode4.4以后,Xcode对@property做了1个增强,只需@property关键字,编译器就会自动生成一个 OC 类中的一个属性</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">@<span class="hljs-keyword">property</span><span class="hljs-title"> </span>NSString *name;<br></code></pre></td></tr></table></figure><h2 id="新版本-porperty-都做了哪些事情"><a href="#新版本-porperty-都做了哪些事情" class="headerlink" title="新版本@porperty 都做了哪些事情?"></a>新版本@porperty 都做了哪些事情?</h2><ol><li>自动的为类生成1个私有属性</li><li>属性的类型和@property类型一致 </li><li>属性的名称和@property的名称一致 并自动为这个属性的名称添加1个下划线.</li><li>自动的生成这个属性的getter setter方法的声明以及实现<ol><li>setter的实现: 直接将参数的值赋值给自动生成的私有属性.</li><li>getter的实现: 直接返回生成的私有属性的值.</li></ol></li></ol><h1 id="新版本-porperty的注意要点有哪些"><a href="#新版本-porperty的注意要点有哪些" class="headerlink" title="新版本@porperty的注意要点有哪些?"></a>新版本@porperty的注意要点有哪些?</h1><ul><li>@property的类型对应类成员属性类型</li><li>@property的名称对应类成员属性的去掉下划线后的属性名</li><li>新版本的@property也支持相同类型的批量声明</li><li>新版本的@property生成的方法实现也没有做任何逻辑验证</li><li>自定义验证逻辑时<ul><li>如果重写了setter 还会自动生成getter</li><li>如果重写了getter 还会自动生成setter </li><li>如果同时重写getter setter 那么就不会自动生成私有属性了,需要手动向类中添加属性</li></ul></li><li>父类的@property一样可以被子类继承</li><li>@property生成的属性是私有的 在子类的内部无法直接访问,但可通过setter getter来访问</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><ul><li>如果你想为类写1个属性 并且为这个属性封装getter setter, 使用@property就搞定,不需要再使用@synthesize</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-6-语言特性-构造方法</title>
    <link href="/2022/07/04/Objective-C-6-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/04/Objective-C-6-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p> \1. 创建对象,我们之前说:</p><p>​     </p><p>   类名 *指针名 &#x3D; [类名 new];</p><p>   new实际上是1个类方法.</p><p>   new方法的作用:</p><p>   -&gt; 创建对象。</p><p>   -》 初始化对象</p><p>   -&gt; 把对象的地址返回.</p><p>   new方法的内部,其实是先调用的alloc方法. 再调用的init方法.</p><p>   alloc方法是1个类方法,作用: 那1个类调用这个方法 就创建那个类的对象,并把对象返回.</p><p>   init方法 是1个对象方法,作用: 初始化对象.</p><p>   创建对象的完整步骤:</p><p>   应该是先使用alloc创建1个对象,然后再使用init初始化这个对象 才可以使用这个对象.</p><p>   虽然没有初始化的对象 有的时候 也可以使用. 但是千万不要这么做.</p><p>   使用1个未经初始化的对象是极其危险的.</p><p>   Person *p1 &#x3D; [Person new];</p><p>   完全等价于</p><p>   Person *p1 &#x3D; [[Person alloc] init];</p><p> \2. init方法.</p><p>   作用: 初始化对象,为对象的属性赋初始值 这个init方法我们叫做构造方法.</p><p>​     init方法做的事情:初始化对象.</p><p>​     为对象的属性赋默认值.</p><p>​     如果属性的类型是基本数据类型就赋值为0</p><p>​            C指针      NULL</p><p>​            OC指针     nil</p><p>   所以.我们创建1个对象如果没有为这个对象的属性赋值 这个对象的属性是有默认值的.</p><p>   所以,我们每次新创建1个对象,这个对象的属性都被初始化了.</p><p> \3. 我们想要让创建的对象的属性的默认值不是 nil NULL 0</p><p>   而是我们自定义的.</p><p>   那么这个时候,我们就可以重写init方法. 在这个方法中按照我们自己的想法为对象的属性赋值.</p><p>   重写init方法的规范:</p><p>   1). 必须要先调用父类的init方法.然后将方法的返回值赋值给self</p><p>   2). 调用init方法初始化对象有可能会失败,如果初始化失败.返回的就是nil</p><p>   3). 判断父类是否初始化成功. 判断self的值是否为nil 如果不为nil说明初始化成功.</p><p>   4). 如果初始化成功 就初始化当前对象的属性.</p><p>   5). 最后 返回self的值.</p><p>   解惑</p><p>   1). 为什么要调用父类的init方法.</p><p>​     因为父类的init方法 会初始化父类的属性. 所以必须要保证当前对象中的父类属性也同时被初始化.</p><p>   2). 为什么要赋值给self？</p><p>​     因为.调用父类的init方法 会返回初始化成功的对象</p><p>​     实际上返回的就是当前对象。但是我们要判断是否初始化成功.</p><p>   无论如何,记住重写init方法的规范.</p><p>   - (instancetype)init</p><p>   {</p><p>​     if(self &#x3D; [super init])</p><p>​     {</p><p>​      &#x2F;&#x2F;初始化当前类的属性的代码;</p><p>​     }</p><p>​     retrun self;</p><p>   }</p><p>   什么时候需要重写init方法:</p><p>   如果你希望创建出来的对象的属性的默认值不是 nil NULL 0 而是我们指定的值.</p><p>   那么这个时候我们就可以重写init方法.</p><p> \3. 重写init方法以后.</p><p>   稍稍不爽的: 这样每次创建出来的对象的属性的值都是一样的.</p><p>   创建对象的时候,对象的属性的值由创建对象的人来指定.而不是写死在init方法中</p><p>   自定义构造方法.</p><p>   规范:</p><p>   1). 自定义构造方法的返回值必须是instancetype</p><p>   2). 自定义构造方法的名称必须以initWith开头.</p><p>   3). 方法的实现和init的要求一样.</p><p>   什么时候要自定义构造方法?</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-2-面向对象</title>
    <link href="/2022/07/04/Objective-C-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/07/04/Objective-C-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="如何定义一个-OC类？"><a href="#如何定义一个-OC类？" class="headerlink" title="如何定义一个 OC类？"></a>如何定义一个 OC类？</h1><ul><li><p>类的定义分为两个部分：类的声明&#x2F;实现</p></li><li><p>类的声明：一般写在.h文件中</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@inteface</span> 类名 : NSObject<br>&#123;<br>类成员变量声明<br>&#125;<br>方法的声明写在这里<br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure></li><li><p>类的属性名 必须要以下划线开头</p></li><li><p>类的实现：一般写在.m文件中</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@implementation</span> 类名<br><br>      将方法的实现写在这里<br><br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="如何创建-OC-类的对象？"><a href="#如何创建-OC-类的对象？" class="headerlink" title="如何创建 OC 类的对象？"></a>如何创建 OC 类的对象？</h1><ul><li><pre><code class="hljs">类名 *对象名 = [类名 new];</code></pre></li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-1-概述</title>
    <link href="/2022/07/04/Objective-C-1-%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/07/04/Objective-C-1-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要学习-Objective-C？"><a href="#为什么要学习-Objective-C？" class="headerlink" title="为什么要学习 Objective-C？"></a>为什么要学习 Objective-C？</h1><ul><li><p>OC,是在 Swift 诞生以前 IOS、MacOS 开发的主要编程语言</p></li><li><p>一些项目随着苹果的更新或多或少都使用了 OC 与 Swift 混编</p></li></ul><p><img src="/./Objective-C-1-%E6%A6%82%E8%BF%B0/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE.png" alt="学习路线图"></p><h1 id="OC和C语言有何种关系？"><a href="#OC和C语言有何种关系？" class="headerlink" title="OC和C语言有何种关系？"></a>OC和C语言有何种关系？</h1><ul><li>OC 是NextStep 公司对C语言进行一层封装后形成的新语言</li><li>在 C语言的基础上增加了面向对象思想</li><li>一些语法封装</li><li>OC 完全兼容 C 语言</li></ul><h1 id="OC是如何写出HelloWorld的？"><a href="#OC是如何写出HelloWorld的？" class="headerlink" title="OC是如何写出HelloWorld的？"></a>OC是如何写出HelloWorld的？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//<br>//  main.m  <br>//  项目名<br>//<br>//  Created by tiger on 2022/7/1.<br>//  Copyright © 2022 itcast. All rights reserved.<br>#import &lt;Foundation/Foundation.h&gt;<br>int main(int argc, const char * argv[]) &#123; <br>    @autoreleasepool &#123;<br>        // insert code here...<br>        NSLog(@&quot;Hello, World!&quot;);<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="HelloWorld-m中有哪些要点？"><a href="#HelloWorld-m中有哪些要点？" class="headerlink" title="HelloWorld.m中有哪些要点？"></a>HelloWorld.m中有哪些要点？</h1><h2 id="后缀名"><a href="#后缀名" class="headerlink" title="后缀名"></a>后缀名</h2><ul><li>OC程序的源文件的后缀名是.m  m代表message 消息，代表OC中 消息机制</li></ul><h2 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h2><ul><li><p>以#号开头，是预处理指令，同1个文件只要#import过,只会包含1份</p></li><li><p>作用: 将文件的内容在预编译的时候拷贝写指令的地方</p></li><li><p>原理: #import指令在包含文件的时候,底层会先判断这个文件是否被包含  如果被包含就会略过 否则才会包含</p></li><li><p>C语言中，如果#include指令要实现这个效果 就必须要配合条件编译指令来实现</p></li></ul><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><ul><li><p>是OC程序的入口和出口                                         &amp;#x20;</p></li><li><p>返回值 int类型 代表程序的结束状态  </p><ul><li>0 代表正常结束 非0代表非正常结束.         &amp;#x20;</li></ul></li><li><p>参数: 命令行运行时，可接收运行时用户入参 也可以无参数&amp;#x20;</p><ul><li>argc代表用户传递的数据的个数.</li><li>argv数组中每个元素存储的就是用户传递过来的数据.</li></ul></li></ul><h2 id="Foundation-x2F-Foundation-h"><a href="#Foundation-x2F-Foundation-h" class="headerlink" title="Foundation&#x2F;Foundation.h"></a>Foundation&#x2F;Foundation.h</h2><ul><li>main 函数中引用了 Foundation框架中的 Foundation.h头文件<ul><li>Foundation.h 中包含了Foundation框架中的其他的所有的头文件</li><li>Foundation.h位于如下路径：<ul><li>&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX10.10.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Foundation.framework&#x2F;Versions&#x2F;C&#x2F;Headers&#x2F;Foundation.h</li></ul></li></ul></li></ul><h2 id="autoreleasepool：自动释放池"><a href="#autoreleasepool：自动释放池" class="headerlink" title="@autoreleasepool：自动释放池"></a>@autoreleasepool：自动释放池</h2><p>- </p><h2 id="NSLog函数"><a href="#NSLog函数" class="headerlink" title="NSLog函数"></a>NSLog函数</h2><ul><li>向控制台输出信息</li><li><code> NSLog(@&quot;格式控制字符串&quot;,变量列表);</code></li></ul><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li><p>输出一些调试相关信息.</p><pre><code class="hljs"><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">2020-07-01</span> <span class="hljs-number">12</span>:<span class="hljs-number">40:52.628</span> Day01-OC基础语法[<span class="hljs-number">784:210576</span>] Hello,World!<br>执行时间                   程序的名称    [进程编号:线程编号]  输出的信息. <br></code></pre></td></tr></table></figure></code></pre></li><li><p>会自动换行 但手动在字符串结尾使用 ‘ \n ’ 则不会自动换行</p></li></ul><h1 id="OC-中如何使用字符串？"><a href="#OC-中如何使用字符串？" class="headerlink" title="OC 中如何使用字符串？"></a>OC 中如何使用字符串？</h1><ul><li><p>在OC中专门设计了1个NSString类型来存储字符串</p></li><li><p>字符串分为C字符串和OC字符串</p><ul><li>“jack” 这是1个C语言的字符串.</li><li>@”jack” 这是1个OC的字符串常量.</li></ul></li><li><p>OC中使用 NSString类型的指针 存储字符串的地址.</p></li><li><p>OC中，字符串常量必须要使用1个前缀@符号.</p></li><li><p>NSLog函数的第1个参数是1个OC字符串,所以NSLog函数的第1个实参应该以@符号开头.</p></li><li><p>如果要使用NSLog函数输出OC字符串的值,那么使用占位符%@</p></li></ul><h1 id="OC-中的NS前缀是什么意思？"><a href="#OC-中的NS前缀是什么意思？" class="headerlink" title="OC 中的NS前缀是什么意思？"></a>OC 中的NS前缀是什么意思？</h1><ul><li>NextStep公司开发 OC —&gt; 公司更名为Cocoa —&gt; Foundation框架之中</li></ul><h1 id="OC-中的-前缀是什么意思？"><a href="#OC-中的-前缀是什么意思？" class="headerlink" title="OC 中的@前缀是什么意思？"></a>OC 中的@前缀是什么意思？</h1><ul><li><p>将C字符串转换为OC字符串.</p></li><li><p>OC中的绝大部分的关键字都是以@符号开头.</p></li></ul><h1 id="OC中的注释？"><a href="#OC中的注释？" class="headerlink" title="OC中的注释？"></a>OC中的注释？</h1><ul><li>和C语言的注释一模一样.分为单行注释和多行注释.</li></ul><h1 id="OC程序是如何运行的？"><a href="#OC程序是如何运行的？" class="headerlink" title="OC程序是如何运行的？"></a>OC程序是如何运行的？</h1><ul><li>程序从代码到可执行文件的三个阶段：  预处理、检查语法、编译、连接、执行</li><li>点击运行按钮 所有的事情Xcode就帮助我们自动的做了</li></ul><h2 id="编译：使用编译器将源代码编译为目标文件"><a href="#编译：使用编译器将源代码编译为目标文件" class="headerlink" title="编译：使用编译器将源代码编译为目标文件"></a>编译：使用编译器将源代码编译为目标文件</h2><p> 终端中编译某一.m文件的命令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> xx.m<br></code></pre></td></tr></table></figure><ul><li>编译.m后会生成中间文件.o</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">cc</span> xx.o -framework 框架名称<br></code></pre></td></tr></table></figure><ul><li><p>如果程序中使用到了框架中的函数或者类.那么在链接的时候,就必须要告诉编译器去哪个框架中找这个函数或者类.</p></li><li><p>链接成功以后 就会生成1个a.out可执行文件 执行就可以了.</p></li></ul><h1 id="OC中都有哪些数据类型？"><a href="#OC中都有哪些数据类型？" class="headerlink" title="OC中都有哪些数据类型？"></a>OC中都有哪些数据类型？</h1><ul><li><p>支持C语言中的所有的数据类型.</p><ul><li><p>基本数据类型：int double float char</p></li><li><p>构造类型：数组 结构体 枚举</p></li><li><p>指针类型： int *p1;</p></li><li><p>空类型：void</p></li><li><p>typedef 自定义类型</p></li></ul></li><li><p>新类型：</p><ul><li><p>BOOL类型：YES或者NO</p><ul><li><p>本质：有符号的char变量</p><ul><li><p>typedef signed char BOOL; </p></li><li><p>#define YES ((BOOL)1）</p></li><li><p>#define NO ((BOOL)0)</p></li></ul></li></ul></li><li><p>Boolean</p><ul><li><p>可以存储true或者flase</p></li><li><p>本质：无符号的char变量</p><ul><li>typedef unsigned char     Boolean;</li><li>#define true 1</li><li>#define false 0</li></ul></li></ul></li><li><p>class 类型 类</p></li><li><p>id类型 万能指针</p></li><li><p>nil 与NULL差不多</p></li><li><p>SEL 方法选择器</p></li><li><p>block 代码段</p></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>OC 是什么，和 C语言关系</li><li>分析 HelloWorld</li><li>OC 程序是如何运行的</li><li>OC 中的数据类型</li></ol>]]></content>
    
    
    <categories>
      
      <category>Objective-C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言基础</tag>
      
      <tag>iOS/MacOS</tag>
      
      <tag>概述</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
