<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-21/"/>
    <url>/2022/07/05/1-21/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-20/"/>
    <url>/2022/07/05/1-20/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-19/"/>
    <url>/2022/07/05/1-19/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-18/"/>
    <url>/2022/07/05/1-18/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-17/"/>
    <url>/2022/07/05/1-17/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-16/"/>
    <url>/2022/07/05/1-16/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-15/"/>
    <url>/2022/07/05/1-15/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-14/"/>
    <url>/2022/07/05/1-14/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-13/"/>
    <url>/2022/07/05/1-13/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-12/"/>
    <url>/2022/07/05/1-12/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-11/"/>
    <url>/2022/07/05/1-11/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-10/"/>
    <url>/2022/07/05/1-10/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-9/"/>
    <url>/2022/07/05/1-9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-8/"/>
    <url>/2022/07/05/1-8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-7/"/>
    <url>/2022/07/05/1-7/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-6/"/>
    <url>/2022/07/05/1-6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-5/"/>
    <url>/2022/07/05/1-5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-4/"/>
    <url>/2022/07/05/1-4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-3/"/>
    <url>/2022/07/05/1-3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-2/"/>
    <url>/2022/07/05/1-2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1-1/"/>
    <url>/2022/07/05/1-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/1/"/>
    <url>/2022/07/05/1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-5-语言特性-万能类型</title>
    <link href="/2022/07/05/Objective-C-5-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E4%B8%87%E8%83%BD%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/07/05/Objective-C-5-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E4%B8%87%E8%83%BD%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="OC中的类型可以"><a href="#OC中的类型可以" class="headerlink" title="OC中的类型可以"></a>OC中的类型可以</h1><p> \1. OC是1门弱语言.</p><p>   编译器在编译的时候.语法检查的时候没有那么严格.</p><p>   不管你怎么写都是可以的.</p><p>   int num &#x3D; 12.12;</p><p>   优点: 灵活 咋个行都写.</p><p>   缺点: 太灵活</p><p>   强类型的语言: 编译器在编译的时候 做语法检查的时候 行就是行 不行就是不行.</p><p> \2. 静态类型:</p><p>   指的是1个指针指向的对象是1个本类对象.</p><p>   动态类型:</p><p>   指的是1个指针指向的对象不是本类对象.</p><p> \3. 编译检查.</p><p>   编译器在编译的时候,能不能通过1个指针去调用指针指向的对象的方法.</p><p>   判断原则: 看指针所属的类型之中是有这个方法,如果有就认为可以调用 编译通过.</p><p>​       如果这个类中没有 那么编译报错.</p><p>   这个叫做编译检查. 在编译的时候 能不能调用对象的方法主要是看指针的类型.</p><p>   我们可以将指针的类型做转换,来达到骗过编译器的目的.</p><p> \4. 运行检查.</p><p>   编译检查只是骗过了编译器. 但是这个方法究竟能不能执行.</p><p>   所以在运行的时候.运行时会去检查对象中是否真的有这个方法.如果有就执行 如果没有就报错误.</p><p> \5. LSP</p><p>   父类指针指向子类对象.</p><p>   实际上任意的指针可以执行任意的对象.编译器是不会报错的.</p><p>   当1个子类指针执行1个父类对象的时候,编译器运行通过子类指针去调用子类独有的方法.</p><p>   但是在运行的时候是会出问题的.因为父类对象中根本没有子类成员.</p><p> \1. NSObject.</p><p>   是OC中所有类的基类.根据LSP NSObject指针就可以指向任意的OC对象.</p><p>   所以.NSObject指针是1个万能指针.可以执行任意的OC对象.</p><p>   缺点: 如果要调用指向的子类对象的独有的方法.就必须要做类型转换.</p><p> \2. id指针.</p><p>   是1个万能指针,可以指向任意的OC对象.</p><p>   1). id是1个typedef自定义类型 在定义的时候已经加了*</p><p>​     所以,声明id指针的时候不需要再加*了.</p><p>   \2) id指针是1个万能指针,任意的OC对象都可以指.</p><p> \3. NSObject和id的异同.</p><p>   相同点: 万能指针 都可以执行任意的OC对象.</p><p>   不同点: 通过NSObject指针去调用对象的方法的时候.编译器会做编译检查.</p><p>​      通过id类型的指针去调用对象的方法的时候,编译器直接通过.无论你调用什么方法.</p><p>   注意: id指针只能调用对象的方法 不能使用点语法.如果使用点语法就会直接报编译错误 。</p><p>   如果我们要声明1个万能指针 千万不要使用NSObject 而是使用id</p><p> \4. 父类中的类方法创建1个父类对象返回.</p><p>   1). 如果返回值写为父类类型的.那么子类来调用这个方法得到的就是父类指针.</p><p>​     解决的方式: 把返回值改为id类型的.</p><p>   2). 方法的内部创建的对象的是 不要写死. 因为写死创建的对象就固定了.</p><p>​     我们希望那1个类来调用这个方法就创建那1个类的对象.</p><p>​     把类名写为self 那1个类来调用这个方法 self就指的是那1个类.创建的就是那1个类的对象.</p><p>   3). 方法的返回值是id类型的.问题就是任意指针都可以接收这个方法的返回值.</p><p>​     编译器连个警告都没有.</p><p>​     如果方法的返回值是instancetype</p><p>​     代表方法的返回值是当前这个类的对象.</p><p>   5). 使用建议</p><p>​     1). 如果方法内部是在创建当前类的对象,不要写死成类名 【类名 new】;</p><p>​       而是用self代替类名.</p><p>​     2). 如果方法的返回值是当前类的对象,也不要写死了. 而是写instancetype</p><p>   6). id和instancetype的区别.</p><p>​     1).instancetype只能作为方法的返回值.不能在别的地方使用.</p><p>​      id既可以声明指针变量 也可以作为参数 也可以作为返回值.</p><p>​     2). instancetype 是1个有类型的 代表当前类的对象.</p><p>​      id是1个无类型的指针 仅仅是1个地址.没有类型的指针.</p><p> \1. 编译检查.</p><p>   编译器在编译的时候. 判断1个指针是否可以调用指向的对象的方法.</p><p>   判断的准则就是指针的类型.</p><p>   LLVM</p><p>   我们可以很轻松的把编译器给骗过.</p><p> \2. 就算骗过了编译器,程序在运行的时候还会做运行检查.</p><p>   我们写的程序就算编译通过了.不意味着可以完美的执行.</p><p> \3. 我们就希望.我们可以写代码来先判断1下.对象中是否有这个方法.如果有再去执行.</p><p>   如果没有就别去执行.</p><p>   1). 判断对象中是否有这个方法可以执行.</p><p>​     - (BOOL)respondsToSelector:(SEL)aSelector;</p><p>​     最常用的是这个方法. </p><p>​     Person *p1 &#x3D; [Person new];</p><p>​     [p1 sayHi];</p><p>   2). 判断类中是否有指定的类方法.</p><p>​     + (BOOL)instancesRespondToSelector:(SEL)aSelector;</p><p>   2). 判断指定的对象是否为 指定类的对象或者子类对象.</p><p>​    - (BOOL)isKindOfClass:(Class)aClass;</p><p>​    BOOL b1 &#x3D; [s1 isKindOfClass:[Person class]];</p><p>​    判断s1对象是否为Person对象或者Person的子类对象.</p><p>   3). 判断对象是否为指定类的对象 不包括子类.</p><p>​     - (BOOL)isMemberOfClass:(Class)aClass;</p><p>​     [s1 isMemberOfClass:[Student class]];</p><p>​     判断s1对象是否为1个Student对象. 不包括Student的子类对象.</p><p>   4). 判断类是否为另外1个类的子类.</p><p>​    + (BOOL)isSubclassOfClass:(Class)aClass;</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-2-面向对象</title>
    <link href="/2022/07/04/Objective-C-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/07/04/Objective-C-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="如何定义一个-OC类？"><a href="#如何定义一个-OC类？" class="headerlink" title="如何定义一个 OC类？"></a>如何定义一个 OC类？</h1><ul><li><p>类的定义分为两个部分：类的声明&#x2F;实现</p></li><li><p>类的声明：一般写在.h文件中</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@inteface</span> 类名 : NSObject<br>&#123;<br>类成员变量声明<br>&#125;<br>方法的声明写在这里<br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure></li><li><p>类的属性名 必须要以下划线开头</p></li><li><p>类的实现：一般写在.m文件中</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@implementation</span> 类名<br><br>      将方法的实现写在这里<br><br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="如何创建-OC-类的对象？"><a href="#如何创建-OC-类的对象？" class="headerlink" title="如何创建 OC 类的对象？"></a>如何创建 OC 类的对象？</h1><ul><li><pre><code class="hljs">类名 *对象名 = [类名 new];</code></pre></li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-3-语言特性-SEL消息</title>
    <link href="/2022/07/04/Objective-C-3-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-SEL%E6%B6%88%E6%81%AF/"/>
    <url>/2022/07/04/Objective-C-3-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-SEL%E6%B6%88%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="OC中类的实际形态是如何的？"><a href="#OC中类的实际形态是如何的？" class="headerlink" title="OC中类的实际形态是如何的？"></a>OC中类的实际形态是如何的？</h1><ul><li>类是以Class对象的形式存储在代码段之中.</li><li>OC 中，一个类 被认为是 元类的对象</li></ul><p>类名:存储的这个类的类名. NSString </p><p>方法存储在类对象之中.如何将方法存储在类对象之中.</p><h1 id="OC中的SEL是什么？"><a href="#OC中的SEL是什么？" class="headerlink" title="OC中的SEL是什么？"></a>OC中的SEL是什么？</h1><ul><li>叫做 selector 选择器</li><li>是一种变量类型，所以要在内存中申请空间存储数据.</li><li>转定义后，SEL本质是1个结构体. </li><li><strong>SEL结构体变量用于存储消息.类似于函数指针</strong><ul><li>消息类似于方法，OC中调用方法一般被称为发送消息</li></ul></li><li>使用SEL对象类发送消息 使编译器不会验证这个方法是否声明，直接向对象发送消息</li><li>一般作为Class对象 的属性，用于将类方法存储到 Class对象 中</li></ul><h1 id="SEL应如何使用？"><a href="#SEL应如何使用？" class="headerlink" title="SEL应如何使用？"></a>SEL应如何使用？</h1><ul><li>创建1个SEL对象，将方法的信息存储在这个SEL对象之中.</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SEL</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-meta">@selector(方法名)</span>;<br></code></pre></td></tr></table></figure><ul><li>SEL使用时不需要加*</li></ul><p><img src="/Users/tiger/Desktop/hexo-blog/source/_posts/Objective-C-3-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-SEL%E6%B6%88%E6%81%AF/1.png" alt="image-20220703122856297"></p><h1 id="OC中调用方法的内部原理是怎样的？"><a href="#OC中调用方法的内部原理是怎样的？" class="headerlink" title="OC中调用方法的内部原理是怎样的？"></a>OC中调用方法的内部原理是怎样的？</h1><ul><li><p>现有这样一个方法，p1是Person类的对象，sayHi是其实例方法</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[p1 sayHi]</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><ol><li>获取到 sayHi 这一消息的 SEL 对象</li><li>将这个SEL消息发送给p1对象，此时，p1对象接收到这个SEL消息以后 就知道要调用方法</li><li>根据p1对象的isa指针寻找存储类Person（Class对象）</li><li>找到这个类（Class对象）以后 在其中去搜寻是否有和传入的SEL数据相匹配的方法</li><li>如果有 就执行  如果没有再向父类寻找 直到NSObject类，若都没有匹配的方法，则抛出异常</li></ol><h1 id="OC的重要机制-消息机制"><a href="#OC的重要机制-消息机制" class="headerlink" title="OC的重要机制:消息机制"></a>OC的重要机制:消息机制</h1><ul><li>调用方法的本质其实就是向对象发送SEL消息.</li><li>[p1 sayHi]; 向p1对象发送1条sayHi消息.</li><li>重点掌握:<br>1).方法是以SEL对象的形式存储起来.<br>2).如何拿到存储方法的SEL对象：Class 对象获取</li></ul><h1 id="SEL消息的其他用法？"><a href="#SEL消息的其他用法？" class="headerlink" title="SEL消息的其他用法？"></a>SEL消息的其他用法？</h1><h2 id="手动发送消息"><a href="#手动发送消息" class="headerlink" title="手动发送消息"></a>手动发送消息</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">调用对象的方法 将SEL数据发送给对象.<br>- <span class="hljs-params">(id)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Person *p1 = [Person <span class="hljs-keyword">new</span>];<br><span class="hljs-type">SEL</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-meta">@selector(sayHi)</span>; <span class="hljs-comment">//先得到方法的SEL数据.</span><br>[p1 performSelector:s1];  <span class="hljs-comment">// 将这个SEL消息发送给p1对象，与 [p1 sayHi]效果是完全一样的.</span><br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h1><ol><li>使用 SEL 对象时，如果方法有参数 那么方法名是带了冒号的 <ol><li>@selector(sayHi:);</li></ol></li><li>如果方法有参数就调用如下方法:</li></ol><ul><li>(id)performSelector:(SEL)aSelector withObject:(id)object;</li><li>(id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</li></ul><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol><li><p>类是以Class对象的形式存储在代码段.</p></li><li><p>如何取到存储类的类对象.</p></li><li><p>如何使用类对象调用类的类方法 </p></li><li><p>方法是以SEL数据的形式存储的.</p></li><li><p>调用方法的两种方式.</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-4-语言特性-getter-setter</title>
    <link href="/2022/07/04/Objective-C-4-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-getter-setter/"/>
    <url>/2022/07/04/Objective-C-4-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-getter-setter/</url>
    
    <content type="html"><![CDATA[<h1 id="OC中是如何访问对象的属性的"><a href="#OC中是如何访问对象的属性的" class="headerlink" title="OC中是如何访问对象的属性的?"></a>OC中是如何访问对象的属性的?</h1><ul><li><p>OC中可以使用点语法来访问对象的属性</p></li><li><p>语法如下所示:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//对象名.去掉下划线的属性名;<br>p1.name = @&quot;jack&quot;; //这个时候就会将@&quot;jack&quot;赋值给p1对象的_name属性.<br>NSString *name = p1.name; //把p1对象的_name属性的值取出来<br></code></pre></td></tr></table></figure><ul><li>但,OC的对象如果要为属性赋值或者取值 就要调用对应的getter或者setter.</li></ul><h1 id="点语法实际是如何进行的"><a href="#点语法实际是如何进行的" class="headerlink" title="点语法实际是如何进行的?"></a>点语法实际是如何进行的?</h1>   <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">p1.age</span> = <span class="hljs-number">18</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>点语法在编译器编译的时候.会将点语法转换为调用setter、getter的代码.</li></ul><h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作:"></a>赋值操作:</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">p1.age</span> = <span class="hljs-number">10</span><span class="hljs-comment">;//对象名.去掉下划线的属性名 = 数据; 转换为</span><br><span class="hljs-section">[p1 setAge:10]</span><span class="hljs-comment">; //  [对象名 set去掉下划线的属性名首字母大写:数据];</span><br></code></pre></td></tr></table></figure><h2 id="取值操作"><a href="#取值操作" class="headerlink" title="取值操作:"></a>取值操作:</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int age <span class="hljs-operator">=</span> p1.age<span class="hljs-comment">;//     对象名.去掉下划线的属性名; 转换为</span><br>int age <span class="hljs-operator">=</span> [p1 age]<span class="hljs-comment">;//    [对象名 去掉下划线的属性名];</span><br></code></pre></td></tr></table></figure><h1 id="点语法注意"><a href="#点语法注意" class="headerlink" title="点语法注意:"></a>点语法注意:</h1><ul><li><p>在getter和setter中慎用点语法,因为有可能会造成无限递归 而程序崩溃</p></li><li><p>setter方法和getter方法名不符合规范 点语法就会出问题.</p></li><li><p>如果属性没有封装getter setter 是无法使用点语法的</p></li></ul><h1 id="property关键字是什么"><a href="#property关键字是什么" class="headerlink" title="@property关键字是什么?"></a>@property关键字是什么?</h1><ul><li><p>为了简化类属性 getter&#x2F;setter的声明代码,用于 <strong>自动生成类属性的getter、setter方法的声明</strong> 的关键字</p></li><li><p>会额外为类生成属性,并不会影响原来类已有的属性</p></li><li><p>因为是生成方法的声明,所以应该写在@interface类的声明之中.</p></li><li><p>语法: @property 数据类型 名称;</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@<span class="hljs-keyword">property</span> <span class="hljs-built_in">int</span> age; <br></code></pre></td></tr></table></figure><h1 id="property的原理是怎样的"><a href="#property的原理是怎样的" class="headerlink" title="@property的原理是怎样的?"></a>@property的原理是怎样的?</h1><ul><li>编译器在编译的时候.会根据@property生成getter和setter方法的实现</li></ul> <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@<span class="hljs-keyword">property</span> <span class="hljs-built_in">int</span> age; <span class="hljs-comment">//@property 数据类型 名称;</span><br>- (<span class="hljs-built_in">void</span>)setAge:(<span class="hljs-built_in">int</span>)age;<span class="hljs-comment">//- (void)set首字母大写的名称:(数据类型)名称;</span><br>- (<span class="hljs-built_in">int</span>)age;<span class="hljs-comment">//- (数据类型)名称;</span><br></code></pre></td></tr></table></figure><h1 id="property注意"><a href="#property注意" class="headerlink" title="@property注意:"></a>@property注意:</h1><ul><li><p><strong>@property的类型</strong>和<strong>属性的类型</strong>一致.</p></li><li><p><strong>@property的名称</strong>和<strong>属性的名称</strong>一致(去掉下划线)</p></li><li><p>@property只是生成getter和setter方法的声明. 实现还要自己来. 属性还要自己定义.</p></li></ul><h1 id="synthesize关键字是什么"><a href="#synthesize关键字是什么" class="headerlink" title="@synthesize关键字是什么?"></a>@synthesize关键字是什么?</h1><ul><li><p>为了简化类属性 getter&#x2F;setter的实现代码,用于 <strong>自动生成类的getter、setter方法的实现</strong> 的关键字</p></li><li><p>因为是生成方法的实现,所以应该写在@implement类的实现之中.</p></li><li><p>语法如下所示:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//--------Person.h<br>@interface Person : NSObject<br>&#123;<br>   int _age;<br>&#125;<br>@property int age;//age 的 getter,setter 声明<br>@end<br><br>//--------Person.m<br>@implmentation Person<br>@synthesize age; //age 的 getter,setter 实现 ;@synthesize @property名称;<br>@end<br><br><br></code></pre></td></tr></table></figure><h1 id="synthesize的原理是怎样的"><a href="#synthesize的原理是怎样的" class="headerlink" title="@synthesize的原理是怎样的?"></a>@synthesize的原理是怎样的?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@implmentation Person<br>  @synthesize age;<br>@end<br>//----------上述代码等同于如下代码:<br>@implementaion Person<br>&#123;<br>  int age;<br>&#125;<br>- (void)setAge:(int)age<br>&#123;<br>  self-&gt;age = age;<br>&#125;<br>- (int)age<br>&#123;<br>  return age;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><h1 id="synthesize做什么工作呢"><a href="#synthesize做什么工作呢" class="headerlink" title="@synthesize做什么工作呢?"></a>@synthesize做什么工作呢?</h1><h2 id="会自动生成的完全私有属性"><a href="#会自动生成的完全私有属性" class="headerlink" title="会自动生成的完全私有属性:"></a>会自动生成的完全私有属性:</h2><ul><li>如下写法会在这一类中自动生成一个完全私有的属性,以及这个属性的 getter 和 setter</li><li>自动生成的属性与外部其他属性无关</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>类的实现部分<br>@synthesize name;<span class="hljs-regexp">//</span>@synthesize 属性名称;<br></code></pre></td></tr></table></figure><ul><li>属性的类型应和@synthesize对应的@property类型或属性声明一致.</li><li>属性的名字应和@synthesize对应的@property名字或属性声明一致.</li></ul><h2 id="自动生成setter方法的实现"><a href="#自动生成setter方法的实现" class="headerlink" title="自动生成setter方法的实现:"></a>自动生成setter方法的实现:</h2><ul><li>实现的方式: 将参数直接赋值给**@synthesize自动生成的私有属性**.并且<strong>不会做任何额外操作</strong>,也不会对其他属性有影响</li></ul><h2 id="自动生成getter方法的实现"><a href="#自动生成getter方法的实现" class="headerlink" title="自动生成getter方法的实现."></a>自动生成getter方法的实现.</h2><ul><li>实现的方式: 直接将**@synthesize自动生成的私有属性的值**返回</li></ul><h1 id="如果属性被写好了-如何使用-synthesize自动生成-getter-和-setter"><a href="#如果属性被写好了-如何使用-synthesize自动生成-getter-和-setter" class="headerlink" title="如果属性被写好了,如何使用@synthesize自动生成 getter 和 setter?"></a>如果属性被写好了,如何使用@synthesize自动生成 getter 和 setter?</h1><ul><li>可以使用如下写法来实现:</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@synthesize</span> age = _age; <span class="hljs-regexp">//</span><span class="hljs-variable">@synthesize</span> 属性(<span class="hljs-variable">@property</span> 的)名称 = 已经存在的属性名;<br></code></pre></td></tr></table></figure><ul><li>这种写法的特点:<ul><li>不会再去生成私有属性.</li><li>直接生成setter getter的实现,且操作的是指定的属性</li></ul></li></ul><h1 id="如何向-synthesize自动生成的getter-和-setter中添加新逻辑"><a href="#如何向-synthesize自动生成的getter-和-setter中添加新逻辑" class="headerlink" title="如何向@synthesize自动生成的getter 和 setter中添加新逻辑?"></a>如何向@synthesize自动生成的getter 和 setter中添加新逻辑?</h1><ul><li><p>@synthesize生成的setter方法实现中 是没有做任何逻辑验证的 是直接赋值.</p></li><li><p>@synthesize生成的getter方法的实现中 是直接返回属性的值.</p></li><li><p>如果setter或者getter有自己的逻辑验证 那么就自己在类的实现中重写就可以了.</p></li></ul><h1 id="当类中有较多属性时-如何简便的向类中添加多个属性的声明及实现"><a href="#当类中有较多属性时-如何简便的向类中添加多个属性的声明及实现" class="headerlink" title="当类中有较多属性时,如何简便的向类中添加多个属性的声明及实现?"></a>当类中有较多属性时,如何简便的向类中添加多个属性的声明及实现?</h1><ul><li>@property只是生成getter setter 的声明</li><li>@synthesize是生成getter setter 的实现</li></ul><h2 id="声明多个类型一致的-property"><a href="#声明多个类型一致的-property" class="headerlink" title="声明多个类型一致的@property"></a>声明多个类型一致的@property</h2> <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@property</span> float <span class="hljs-attribute">height</span>,weight;<br></code></pre></td></tr></table></figure><h2 id="声明多个-synthesize"><a href="#声明多个-synthesize" class="headerlink" title="声明多个@synthesize"></a>声明多个@synthesize</h2><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">@synthesize <span class="hljs-built_in">name</span> = <span class="hljs-variable">_name</span>,age = <span class="hljs-variable">_age</span>,weight = <span class="hljs-variable">_weight</span>,height = <span class="hljs-variable">_height</span>;<br></code></pre></td></tr></table></figure><h1 id="新版本的-property"><a href="#新版本的-property" class="headerlink" title="新版本的@property"></a>新版本的@property</h1><ul><li>Xcode4.4以后,Xcode对@property做了1个增强,只需@property关键字,编译器就会自动生成一个 OC 类中的一个属性</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">@<span class="hljs-keyword">property</span><span class="hljs-title"> </span>NSString *name;<br></code></pre></td></tr></table></figure><h2 id="新版本-porperty-都做了哪些事情"><a href="#新版本-porperty-都做了哪些事情" class="headerlink" title="新版本@porperty 都做了哪些事情?"></a>新版本@porperty 都做了哪些事情?</h2><ol><li>自动的为类生成1个私有属性</li><li>属性的类型和@property类型一致 </li><li>属性的名称和@property的名称一致 并自动为这个属性的名称添加1个下划线.</li><li>自动的生成这个属性的getter setter方法的声明以及实现<ol><li>setter的实现: 直接将参数的值赋值给自动生成的私有属性.</li><li>getter的实现: 直接返回生成的私有属性的值.</li></ol></li></ol><h1 id="新版本-porperty的注意要点有哪些"><a href="#新版本-porperty的注意要点有哪些" class="headerlink" title="新版本@porperty的注意要点有哪些?"></a>新版本@porperty的注意要点有哪些?</h1><ul><li>@property的类型对应类成员属性类型</li><li>@property的名称对应类成员属性的去掉下划线后的属性名</li><li>新版本的@property也支持相同类型的批量声明</li><li>新版本的@property生成的方法实现也没有做任何逻辑验证</li><li>自定义验证逻辑时<ul><li>如果重写了setter 还会自动生成getter</li><li>如果重写了getter 还会自动生成setter </li><li>如果同时重写getter setter 那么就不会自动生成私有属性了,需要手动向类中添加属性</li></ul></li><li>父类的@property一样可以被子类继承</li><li>@property生成的属性是私有的 在子类的内部无法直接访问,但可通过setter getter来访问</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><ul><li>如果你想为类写1个属性 并且为这个属性封装getter setter, 使用@property就搞定,不需要再使用@synthesize</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-6-语言特性-构造方法</title>
    <link href="/2022/07/04/Objective-C-6-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/04/Objective-C-6-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-1-概述</title>
    <link href="/2022/07/04/Objective-C-1-%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/07/04/Objective-C-1-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要学习-Objective-C？"><a href="#为什么要学习-Objective-C？" class="headerlink" title="为什么要学习 Objective-C？"></a>为什么要学习 Objective-C？</h1><ul><li><p>OC,是在 Swift 诞生以前 IOS、MacOS 开发的主要编程语言</p></li><li><p>一些项目随着苹果的更新或多或少都使用了 OC 与 Swift 混编</p></li></ul><p><img src="/Users/tiger/Desktop/hexo-blog/source/_posts/Objective-C-1-%E6%A6%82%E8%BF%B0/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE.png" alt="学习路线图"></p><h1 id="OC和C语言有何种关系？"><a href="#OC和C语言有何种关系？" class="headerlink" title="OC和C语言有何种关系？"></a>OC和C语言有何种关系？</h1><ul><li>OC 是NextStep 公司对C语言进行一层封装后形成的新语言</li><li>在 C语言的基础上增加了面向对象思想</li><li>一些语法封装</li><li>OC 完全兼容 C 语言</li></ul><h1 id="OC是如何写出HelloWorld的？"><a href="#OC是如何写出HelloWorld的？" class="headerlink" title="OC是如何写出HelloWorld的？"></a>OC是如何写出HelloWorld的？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//<br>//  main.m  <br>//  项目名<br>//<br>//  Created by tiger on 2022/7/1.<br>//  Copyright © 2022 itcast. All rights reserved.<br>#import &lt;Foundation/Foundation.h&gt;<br>int main(int argc, const char * argv[]) &#123; <br>    @autoreleasepool &#123;<br>        // insert code here...<br>        NSLog(@&quot;Hello, World!&quot;);<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="HelloWorld-m中有哪些要点？"><a href="#HelloWorld-m中有哪些要点？" class="headerlink" title="HelloWorld.m中有哪些要点？"></a>HelloWorld.m中有哪些要点？</h1><h2 id="后缀名"><a href="#后缀名" class="headerlink" title="后缀名"></a>后缀名</h2><ul><li>OC程序的源文件的后缀名是.m  m代表message 消息，代表OC中 消息机制</li></ul><h2 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h2><ul><li><p>以#号开头，是预处理指令，同1个文件只要#import过,只会包含1份</p></li><li><p>作用: 将文件的内容在预编译的时候拷贝写指令的地方</p></li><li><p>原理: #import指令在包含文件的时候,底层会先判断这个文件是否被包含  如果被包含就会略过 否则才会包含</p></li><li><p>C语言中，如果#include指令要实现这个效果 就必须要配合条件编译指令来实现</p></li></ul><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><ul><li><p>是OC程序的入口和出口                                         &amp;#x20;</p></li><li><p>返回值 int类型 代表程序的结束状态  </p><ul><li>0 代表正常结束 非0代表非正常结束.         &amp;#x20;</li></ul></li><li><p>参数: 命令行运行时，可接收运行时用户入参 也可以无参数&amp;#x20;</p><ul><li>argc代表用户传递的数据的个数.</li><li>argv数组中每个元素存储的就是用户传递过来的数据.</li></ul></li></ul><h2 id="Foundation-x2F-Foundation-h"><a href="#Foundation-x2F-Foundation-h" class="headerlink" title="Foundation&#x2F;Foundation.h"></a>Foundation&#x2F;Foundation.h</h2><ul><li>main 函数中引用了 Foundation框架中的 Foundation.h头文件<ul><li>Foundation.h 中包含了Foundation框架中的其他的所有的头文件</li><li>Foundation.h位于如下路径：<ul><li>&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX10.10.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Foundation.framework&#x2F;Versions&#x2F;C&#x2F;Headers&#x2F;Foundation.h</li></ul></li></ul></li></ul><h2 id="autoreleasepool：自动释放池"><a href="#autoreleasepool：自动释放池" class="headerlink" title="@autoreleasepool：自动释放池"></a>@autoreleasepool：自动释放池</h2><p>- </p><h2 id="NSLog函数"><a href="#NSLog函数" class="headerlink" title="NSLog函数"></a>NSLog函数</h2><ul><li>向控制台输出信息</li><li><code> NSLog(@&quot;格式控制字符串&quot;,变量列表);</code></li></ul><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li><p>输出一些调试相关信息.</p><pre><code class="hljs"><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">2020-07-01</span> <span class="hljs-number">12</span>:<span class="hljs-number">40:52.628</span> Day01-OC基础语法[<span class="hljs-number">784:210576</span>] Hello,World!<br>执行时间                   程序的名称    [进程编号:线程编号]  输出的信息. <br></code></pre></td></tr></table></figure></code></pre></li><li><p>会自动换行 但手动在字符串结尾使用 ‘ \n ’ 则不会自动换行</p></li></ul><h1 id="OC-中如何使用字符串？"><a href="#OC-中如何使用字符串？" class="headerlink" title="OC 中如何使用字符串？"></a>OC 中如何使用字符串？</h1><ul><li><p>在OC中专门设计了1个NSString类型来存储字符串</p></li><li><p>字符串分为C字符串和OC字符串</p><ul><li>“jack” 这是1个C语言的字符串.</li><li>@”jack” 这是1个OC的字符串常量.</li></ul></li><li><p>OC中使用 NSString类型的指针 存储字符串的地址.</p></li><li><p>OC中，字符串常量必须要使用1个前缀@符号.</p></li><li><p>NSLog函数的第1个参数是1个OC字符串,所以NSLog函数的第1个实参应该以@符号开头.</p></li><li><p>如果要使用NSLog函数输出OC字符串的值,那么使用占位符%@</p></li></ul><h1 id="OC-中的NS前缀是什么意思？"><a href="#OC-中的NS前缀是什么意思？" class="headerlink" title="OC 中的NS前缀是什么意思？"></a>OC 中的NS前缀是什么意思？</h1><ul><li>NextStep公司开发 OC —&gt; 公司更名为Cocoa —&gt; Foundation框架之中</li></ul><h1 id="OC-中的-前缀是什么意思？"><a href="#OC-中的-前缀是什么意思？" class="headerlink" title="OC 中的@前缀是什么意思？"></a>OC 中的@前缀是什么意思？</h1><ul><li><p>将C字符串转换为OC字符串.</p></li><li><p>OC中的绝大部分的关键字都是以@符号开头.</p></li></ul><h1 id="OC中的注释？"><a href="#OC中的注释？" class="headerlink" title="OC中的注释？"></a>OC中的注释？</h1><ul><li>和C语言的注释一模一样.分为单行注释和多行注释.</li></ul><h1 id="OC程序是如何运行的？"><a href="#OC程序是如何运行的？" class="headerlink" title="OC程序是如何运行的？"></a>OC程序是如何运行的？</h1><ul><li>程序从代码到可执行文件的三个阶段：  预处理、检查语法、编译、连接、执行</li><li>点击运行按钮 所有的事情Xcode就帮助我们自动的做了</li></ul><h2 id="编译：使用编译器将源代码编译为目标文件"><a href="#编译：使用编译器将源代码编译为目标文件" class="headerlink" title="编译：使用编译器将源代码编译为目标文件"></a>编译：使用编译器将源代码编译为目标文件</h2><p> 终端中编译某一.m文件的命令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> xx.m<br></code></pre></td></tr></table></figure><ul><li>编译.m后会生成中间文件.o</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">cc</span> xx.o -framework 框架名称<br></code></pre></td></tr></table></figure><ul><li><p>如果程序中使用到了框架中的函数或者类.那么在链接的时候,就必须要告诉编译器去哪个框架中找这个函数或者类.</p></li><li><p>链接成功以后 就会生成1个a.out可执行文件 执行就可以了.</p></li></ul><h1 id="OC中都有哪些数据类型？"><a href="#OC中都有哪些数据类型？" class="headerlink" title="OC中都有哪些数据类型？"></a>OC中都有哪些数据类型？</h1><ul><li><p>支持C语言中的所有的数据类型.</p><ul><li><p>基本数据类型：int double float char</p></li><li><p>构造类型：数组 结构体 枚举</p></li><li><p>指针类型： int *p1;</p></li><li><p>空类型：void</p></li><li><p>typedef 自定义类型</p></li></ul></li><li><p>新类型：</p><ul><li><p>BOOL类型：YES或者NO</p><ul><li><p>本质：有符号的char变量</p><ul><li><p>typedef signed char BOOL; </p></li><li><p>#define YES ((BOOL)1）</p></li><li><p>#define NO ((BOOL)0)</p></li></ul></li></ul></li><li><p>Boolean</p><ul><li><p>可以存储true或者flase</p></li><li><p>本质：无符号的char变量</p><ul><li>typedef unsigned char     Boolean;</li><li>#define true 1</li><li>#define false 0</li></ul></li></ul></li><li><p>class 类型 类</p></li><li><p>id类型 万能指针</p></li><li><p>nil 与NULL差不多</p></li><li><p>SEL 方法选择器</p></li><li><p>block 代码段</p></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>OC 是什么，和 C语言关系</li><li>分析 HelloWorld</li><li>OC 程序是如何运行的</li><li>OC 中的数据类型</li></ol>]]></content>
    
    
    <categories>
      
      <category>Objective-C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言基础</tag>
      
      <tag>iOS/MacOS</tag>
      
      <tag>概述</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
