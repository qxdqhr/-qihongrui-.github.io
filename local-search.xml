<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/06/Swift/"/>
    <url>/2022/07/06/Swift/</url>
    
    <content type="html"><![CDATA[<p>除了使用函数做为获取接口的方法外,在swift中给出了<a href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a>(set)申明的方式来限制外部对属性的修改.但在当前文件中依然可改.</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> : <span class="hljs-keyword">String</span>?<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2022/07/05/Objective-C-9/"/>
    <url>/2022/07/05/Objective-C-9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-8-内存管理-MRC</title>
    <link href="/2022/07/05/Objective-C-8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-MRC/"/>
    <url>/2022/07/05/Objective-C-8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-MRC/</url>
    
    <content type="html"><![CDATA[<h1 id="MRC-和-ARC-是什么意思"><a href="#MRC-和-ARC-是什么意思" class="headerlink" title="MRC 和 ARC 是什么意思?"></a>MRC 和 ARC 是什么意思?</h1><ul><li><p>MRC: Manual Reference Counting 手动引用计数.手动内存管理.</p><ul><li>要求程序员手动的管理内存(发送retain消息 或 relase消息)</li><li>早期的APP开发使用的MRC技术</li></ul></li><li><p>ARC: Automatic Reference Counting 自动引用计数.自动内存管理</p><ul><li>系统自动的在合适的地方发送retain relase消息</li><li>ARC是基于MRC</li><li>iOS5开始. Xcode4.2开始就支持ARC,Xcode7 默认支持ARC开发</li></ul></li></ul><h1 id="引用计数器是什么"><a href="#引用计数器是什么" class="headerlink" title="引用计数器是什么?"></a>引用计数器是什么?</h1><ul><li>为了让系统知道何时需要将某个对象所占用的内存清理掉,系统引入了引用计数器的概念</li><li>每个对象都有1个叫做retainCount的属性</li><li>这一属性叫做引用计数器</li><li>类型是unsigned long 占据8个字节</li></ul><h2 id="引用计数器有什么作用"><a href="#引用计数器有什么作用" class="headerlink" title="引用计数器有什么作用?"></a>引用计数器有什么作用?</h2><ul><li>记录当前对象有多少个人在使用它.   </li><li>默认情况下,创建1个对象后,其引用计数器的默认值是1</li><li>当多1个人使用这个对象的时候.应该先让这个对象的引用计数器的值+1 代表这个对象多1个人使用.</li><li>当这个对象少1个人使用的时候.应该先让这个对象的引用计数器的值-1 代表这个对象少1个人使用.</li><li>当这个对象的引用计数器变为0的时候.代表这个对象无人使用. 这个时候系统就会自动回收这个对象.</li></ul><h2 id="如何操作引用计数器"><a href="#如何操作引用计数器" class="headerlink" title="如何操作引用计数器?"></a>如何操作引用计数器?</h2><ul><li>每多1个人使用对象时,为对象发送1条retain消息. 对象的引用计数器就会加1</li><li>每少1个人使用对象的时候,为对象发送1条release消息.对象的引用计数器就会减1</li><li>为对象发送1条retainCount消息. 就可以获取到对象的引用计数器的值</li><li>就这样++ – 当对象的引用计数器变为0的时候,对象就会被系统立即回收,并自动调用对象的dealloc方法.</li></ul><h2 id="重写dealloc方法的规范"><a href="#重写dealloc方法的规范" class="headerlink" title="重写dealloc方法的规范:"></a>重写dealloc方法的规范:</h2><ul><li>必须要调用父类的dealloc方法. 并且要放在最后一句代码.</li></ul><h1 id="野指针是什么"><a href="#野指针是什么" class="headerlink" title="野指针是什么?"></a>野指针是什么?</h1><ul><li><p>OC中的野指针: </p></li><li><p>指针指向的对象已经被回收</p></li><li><p>C语言中的野指针: </p></li><li><p>定义1个指针变量且没有初始化</p></li><li><p>这个指针变量的值指向1块随机的空间</p></li></ul><h1 id="对象回收的是怎样的"><a href="#对象回收的是怎样的" class="headerlink" title="对象回收的是怎样的?"></a>对象回收的是怎样的?</h1><ul><li>回收对象后,对象占用的空间可以分配给别人</li><li>当这个对象占用的内存空间没有分配给别人之前 其实对象数据还在</li></ul><h2 id="内存回收的本质是怎样的"><a href="#内存回收的本质是怎样的" class="headerlink" title="内存回收的本质是怎样的?"></a>内存回收的本质是怎样的?</h2><ul><li>申请1个变量,实际上就是向系统申请指定字节数的空间.这些空间系统就不会再分配给别人了.</li><li>当变量被回收的时候,代表变量占用的字节空间从此以后系统可以分配给别人使用了.</li><li>但此时字节空间中存储的数据还在.</li></ul><h1 id="僵尸对象是什么"><a href="#僵尸对象是什么" class="headerlink" title="僵尸对象是什么?"></a>僵尸对象是什么?</h1><ul><li><p>已经被释放的对象,但是这个对象所占的空间还没有分配给别人.这样的对象叫做僵尸对象.</p></li><li><p>通过野指针去访问僵尸对象的时候:</p><ul><li>当僵尸对象占用的空间还没有分配给别人的时候.这是可以的</li><li>当僵尸对象占用的空间分配给了别人使用的时候 就不可以</li><li>因此,只要对象称为了僵尸对象,无论如何 都不允许访问</li></ul></li><li><p>编译器支持 僵尸对象的实时检查机制 </p><ul><li>打开之后 只要访问的是僵尸对象,无论空间是否分配 就会报错</li><li>但默认状态下僵尸对象检测,不会打开,由于僵尸对象检测打开后,每访问1个对象 都会先检查这个对象是否为僵尸对象,极其消耗性能</li></ul></li><li><p>释放过的僵尸对象不能动态回复</p></li></ul><h1 id="如何避免野指针访问僵尸对象"><a href="#如何避免野指针访问僵尸对象" class="headerlink" title="如何避免野指针访问僵尸对象?"></a>如何避免野指针访问僵尸对象?</h1><ul><li><p>当1个指针的空间被回收后,将这个指针的值设置nil</p></li><li><p>nil指针调用对象的方法(包括使用点语法)时,不会报错. 只是没有任何反应</p><ul><li>但nil 指针不能直接访问属性,会报错.</li></ul></li></ul><h1 id="内存泄露是什么意思"><a href="#内存泄露是什么意思" class="headerlink" title="内存泄露是什么意思?"></a>内存泄露是什么意思?</h1><ul><li>指的是1个对象没有被及时的回收.会一直驻留在内存中,直到程序结束的时候才回收</li><li>这种内存空间,既不能被使用,也不能被回收,不能再被访问到,使得进程中可利用的内存变少,所以被称为内存泄漏</li></ul><h2 id="单个对象会在什么时候发生内存泄露"><a href="#单个对象会在什么时候发生内存泄露" class="headerlink" title="单个对象会在什么时候发生内存泄露?"></a>单个对象会在什么时候发生内存泄露?</h2><ul><li><p>有对象的创建,而没有对应的relase</p></li><li><p>retain的次数和relase的次数不匹配</p></li><li><p>在不适当的时候,为指针赋值为nil</p></li><li><p>在方法中为传入的对象进行不适当的retain</p></li></ul><h2 id="如何保证单个对象可以被回收-规避内存泄漏"><a href="#如何保证单个对象可以被回收-规避内存泄漏" class="headerlink" title="如何保证单个对象可以被回收,规避内存泄漏?"></a>如何保证单个对象可以被回收,规避内存泄漏?</h2><ul><li><p>有对象的创建 就必须要匹配1个relase</p></li><li><p>retain次数和release次数一定要匹配</p></li><li><p>只有在指针称为野指针的时候才赋值为nil</p></li><li><p>在方法中布要随意的为传入的对象retain</p></li></ul><h1 id="MRC-模式下-当属性为OC对象时-setter方法的写法"><a href="#MRC-模式下-当属性为OC对象时-setter方法的写法" class="headerlink" title="MRC 模式下,当属性为OC对象时,setter方法的写法"></a>MRC 模式下,当属性为OC对象时,setter方法的写法</h1><ul><li><p>对象一般都放置在堆区,因此以对象作为属性时,也要遵守 MRC 手动回收内存的原则</p></li><li><p>将参数赋值给当前对象的属性,代表</p><ul><li>属性原值要被删除:原对象需要先释放为原对象发送一个 release 消息</li><li>属性新值需要被存储:参数对象要被存储为参数对象发送一个 retain 消息 </li><li>属性新值赋值:将参数对象赋值到类属性中</li></ul></li><li><p>当对象销毁时,代表属性指向的对象应被释放. 就应该在dealloc中relase</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)setCar:(Car *)car<br>&#123;<br>[_car release];<br>_car = [car retain];<br>&#125;<br>- (void)dealloc //MRC 下需要重写dealloc,手动释放内存<br>&#123;<br>    [_car release];<br>    [super dealloc];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="循环引用是什么意思"><a href="#循环引用是什么意思" class="headerlink" title="循环引用是什么意思?"></a>循环引用是什么意思?</h1><ul><li>当两个类相互包含时,会出现循环引用的问题. 会造成无限递归,而导致无法编译通过<ul><li>Person.h 中 包含(#import) Book.h 同时 Book.h 中 包含(#import) Person.h</li></ul></li></ul><h2 id="如何打破循环引用"><a href="#如何打破循环引用" class="headerlink" title="如何打破循环引用?"></a>如何打破循环引用?</h2><ol><li>将 A.h 中的 #import “B.h” 更换为 @class B; </li><li>在 A.m 文件中 添加  #import “B.h”</li></ol><h1 id="class与-import的区别"><a href="#class与-import的区别" class="headerlink" title="@class与#import的区别?"></a>@class与#import的区别?</h1><ul><li>#import是将指定的文件的内容拷贝到写指令的地方</li><li>@class 并不会拷贝任何内容. 而是令编译器在编译的时候才可以知道xxx是1个类,防止循环引用的产生</li></ul><h1 id="MRC-标准的代码如下"><a href="#MRC-标准的代码如下" class="headerlink" title="MRC 标准的代码如下:"></a>MRC 标准的代码如下:</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//---Person.h<br>#import &lt;Foundation/Foundation.h&gt;<br>@interface Person : NSObject<br>&#123;<br>    //NSString *_name;<br>&#125;<br>//- (void)setName:(NSString *)name;<br>//- (NSString *)name;<br>@property(nonatomic,assign)NSString *name;<br><br>@end<br><br>//---Person.m<br>#import &quot;Person.h&quot;<br>@implementation Person<br><br>- (void)dealloc<br>&#123;<br>    [_name release]; //释放掉属性<br>    [super dealloc]; //调用父类 dealloc<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-5-语言特性-万能类型</title>
    <link href="/2022/07/05/Objective-C-5-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E4%B8%87%E8%83%BD%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/07/05/Objective-C-5-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E4%B8%87%E8%83%BD%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="OC中的数据类型有什么特点"><a href="#OC中的数据类型有什么特点" class="headerlink" title="OC中的数据类型有什么特点?"></a>OC中的数据类型有什么特点?</h1><ul><li>OC是1门弱类型语言<ul><li>编译器在编译的时候.语法检查的时候没有那么严格.</li><li>强类型的语言: 编译器在编译的时候 做语法检查的时候 必须类型一致</li></ul></li><li>静态类型:指针指向的对象是1个本类对象</li><li>动态类型:指针指向的对象不是本类对象</li></ul><h1 id="OC中的编译检查和运行检查是什么"><a href="#OC中的编译检查和运行检查是什么" class="headerlink" title="OC中的编译检查和运行检查是什么?"></a>OC中的编译检查和运行检查是什么?</h1><ul><li><p>编译器在编译的时候,判断1个指针能否调用其指向的对象的方法,这一操作被称为编译检查</p><ul><li>如果<strong>指针所属的类型</strong>中存在对应方法,编译通过</li><li>如果<strong>指针所属的类型</strong>中不存在对应方法,编译报错</li></ul></li><li><p>由于 OC 是弱类型语言,可以将指针的类型转换,使编译器不会报错</p><ul><li>但是在运行时会检查对象中是否真存在对应方法<ul><li>如果有就执行 ,没有就报错误</li></ul></li></ul></li><li><p>这两种检查方式分别被称为编译检查和运行检查</p></li></ul><h1 id="LSP-里氏置换原则"><a href="#LSP-里氏置换原则" class="headerlink" title="LSP:里氏置换原则"></a>LSP:里氏置换原则</h1><ul><li>父类指针指向子类对象<ul><li>这种情况下子类对象是父类的实际实现,从面向对象的思想来看,是一种细化的过程,所以编译器不会报错</li><li>实际上在 OC 中,任意的指针可以执行任意的对象.编译器都不会报错</li></ul></li><li>注意:子类指针可以存储父类对象,但无法调用子类中的有的属性以及方法</li></ul><h1 id="OC-中的-NSObject-类"><a href="#OC-中的-NSObject-类" class="headerlink" title="OC 中的 NSObject 类"></a>OC 中的 NSObject 类</h1><ul><li><p>是OC中所有类的基类</p></li><li><p>根据LSP里氏替换原则, NSObject类型的指针可以指向任意一个OC对象.</p></li><li><p>从这一角度来看, NSObject类型的指针是1种万能指针,可以执行任意的OC对象.</p></li><li><p>但如果要调用对应子类对象的独有方法时,必须要做类型转换</p></li></ul><h1 id="id指针-–真正的万能类型"><a href="#id指针-–真正的万能类型" class="headerlink" title="id指针 –真正的万能类型"></a>id指针 –真正的万能类型</h1><ul><li><p>是1个万能指针,可以指向任意的OC对象.</p></li><li><p>id是1个typedef自定义类型 在定义的时候已经加了*,声明id指针的时候不需要再加*了.</p></li></ul><p>![截屏2022-07-05 21.03.05](.&#x2F;Objective-C-5-语言特性-万能类型.assets&#x2F;截屏2022-07-05 21.03.05-7026201.png)</p><h1 id="NSObject指针和id指针的异同"><a href="#NSObject指针和id指针的异同" class="headerlink" title="NSObject指针和id指针的异同"></a>NSObject指针和id指针的异同</h1><ul><li><p>相同点: </p><ul><li>万能指针 都可以存储任意的OC对象</li></ul></li><li><p>不同点: </p><ul><li>NSObject指针 调用对象的方法时 编译器会做编译检查.</li><li>id类型的指针 调用对象的方法时 编译器直接通过.无论你调用什么方法.</li></ul></li><li><p>注意:</p><ul><li>id指针只能调用对象的方法 不能使用点语法.如果使用点语法就会直接报编译错误</li><li>声明1个万能指针时 应该使用 id</li></ul></li></ul><h1 id="id-指针的其他应用"><a href="#id-指针的其他应用" class="headerlink" title="id 指针的其他应用:"></a>id 指针的其他应用:</h1><h2 id="父类中的类方法-返回一个父类对象-此方法需要子类进行调用"><a href="#父类中的类方法-返回一个父类对象-此方法需要子类进行调用" class="headerlink" title="父类中的类方法,返回一个父类对象,此方法需要子类进行调用"></a>父类中的类方法,返回一个父类对象,此方法需要子类进行调用</h2><ul><li>子类不能存储父类对象,如果返回值写为父类类型的.那么子类来调用这个方法得到的就是父类指针.<ul><li>可以把返回值改为id类型,但此时任意指针都可以接收这个方法的返回值,且编译器不会发出警告</li><li>此时可以使用instancetype</li><li>注意:<ul><li>方法的内部创建的对象时一般不要写死;因为写死创建的对象就固定了</li></ul></li></ul></li></ul><h2 id="任意类来调用某方法就创建那个类的对象"><a href="#任意类来调用某方法就创建那个类的对象" class="headerlink" title="任意类来调用某方法就创建那个类的对象"></a>任意类来调用某方法就创建那个类的对象</h2><ul><li>通过 [self new] 方式创建本类对象</li><li>返回值 不使用 id 而是用 instancetype</li></ul><h1 id="id和instancetype的区别"><a href="#id和instancetype的区别" class="headerlink" title="id和instancetype的区别"></a>id和instancetype的区别</h1><ul><li><p>不同点:</p><ul><li><p>instancetype只能作为方法的返回值.不能在别的地方使用.</p></li><li><p>instancetype 是1个有类型的 代表当前类的对象.</p></li><li><p>id既可以声明指针变量 也可以作为参数 也可以作为返回值.</p></li><li><p>id是1个无类型的指针 仅仅是1个地址.没有类型的指针.</p></li></ul></li></ul><h1 id="编译检查中可以使用哪些操作"><a href="#编译检查中可以使用哪些操作" class="headerlink" title="编译检查中可以使用哪些操作?"></a>编译检查中可以使用哪些操作?</h1><h2 id="判断对象中是否有这个方法可以执行"><a href="#判断对象中是否有这个方法可以执行" class="headerlink" title="判断对象中是否有这个方法可以执行."></a>判断对象中是否有这个方法可以执行.</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>respondsToSelector:<span class="hljs-params">(SEL)</span>aSelector;<br></code></pre></td></tr></table></figure><h2 id="判断类中是否有指定的类方法"><a href="#判断类中是否有指定的类方法" class="headerlink" title="判断类中是否有指定的类方法."></a>判断类中是否有指定的类方法.</h2>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">+ (BOOL)instancesRespondToSelector:(SEL)aSelector;<br></code></pre></td></tr></table></figure><h2 id="判断指定的对象是否为-指定类的对象或者子类对象"><a href="#判断指定的对象是否为-指定类的对象或者子类对象" class="headerlink" title="判断指定的对象是否为 指定类的对象或者子类对象."></a>判断指定的对象是否为 指定类的对象或者子类对象.</h2>  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>isKindOfClass:<span class="hljs-params">(Class)</span>aClass;<br></code></pre></td></tr></table></figure><h2 id="判断对象是否为指定类的对象-不包括子类"><a href="#判断对象是否为指定类的对象-不包括子类" class="headerlink" title="判断对象是否为指定类的对象 不包括子类."></a>判断对象是否为指定类的对象 不包括子类.</h2>  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>isMemberOfClass:<span class="hljs-params">(Class)</span>aClass;<br></code></pre></td></tr></table></figure><h2 id="判断类是否为另外1个类的子类"><a href="#判断类是否为另外1个类的子类" class="headerlink" title="判断类是否为另外1个类的子类."></a>判断类是否为另外1个类的子类.</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">+ <span class="hljs-comment">(BOOL)</span>isSubclassOfClass:<span class="hljs-comment">(Class)</span>aClass;<br></code></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-2-面向对象</title>
    <link href="/2022/07/04/Objective-C-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/07/04/Objective-C-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="如何定义一个-OC类？"><a href="#如何定义一个-OC类？" class="headerlink" title="如何定义一个 OC类？"></a>如何定义一个 OC类？</h1><ul><li><p>类的定义分为两个部分：类的声明&#x2F;实现</p></li><li><p>类的声明：一般写在.h文件中</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@inteface</span> 类名 : NSObject<br>&#123;<br>类成员变量声明<br>&#125;<br>方法的声明写在这里<br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure></li><li><p>类的属性名 必须要以下划线开头</p></li><li><p>类的实现：一般写在.m文件中</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@implementation</span> 类名<br><br>      将方法的实现写在这里<br><br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="如何创建-OC-类的对象？"><a href="#如何创建-OC-类的对象？" class="headerlink" title="如何创建 OC 类的对象？"></a>如何创建 OC 类的对象？</h1><ul><li><pre><code class="hljs">类名 *对象名 = [类名 new];</code></pre></li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-3-语言特性-SEL消息</title>
    <link href="/2022/07/04/Objective-C-3-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-SEL%E6%B6%88%E6%81%AF/"/>
    <url>/2022/07/04/Objective-C-3-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-SEL%E6%B6%88%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="OC中类的实际形态是如何的？"><a href="#OC中类的实际形态是如何的？" class="headerlink" title="OC中类的实际形态是如何的？"></a>OC中类的实际形态是如何的？</h1><ul><li>类是以Class对象的形式存储在代码段之中.</li><li>OC 中，一个类 被认为是 元类的对象</li></ul><p>类名:存储的这个类的类名. NSString </p><p>方法存储在类对象之中.如何将方法存储在类对象之中.</p><h1 id="OC中的SEL是什么？"><a href="#OC中的SEL是什么？" class="headerlink" title="OC中的SEL是什么？"></a>OC中的SEL是什么？</h1><ul><li>叫做 selector 选择器</li><li>是一种变量类型，所以要在内存中申请空间存储数据.</li><li>转定义后，SEL本质是1个结构体. </li><li><strong>SEL结构体变量用于存储消息.类似于函数指针</strong><ul><li>消息类似于方法，OC中调用方法一般被称为发送消息</li></ul></li><li>使用SEL对象类发送消息 使编译器不会验证这个方法是否声明，直接向对象发送消息</li><li>一般作为Class对象 的属性，用于将类方法存储到 Class对象 中</li></ul><h1 id="SEL应如何使用？"><a href="#SEL应如何使用？" class="headerlink" title="SEL应如何使用？"></a>SEL应如何使用？</h1><ul><li>创建1个SEL对象，将方法的信息存储在这个SEL对象之中.</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SEL</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-meta">@selector(方法名)</span>;<br></code></pre></td></tr></table></figure><ul><li>SEL使用时不需要加*</li></ul><p><img src="/./Objective-C-3-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-SEL%E6%B6%88%E6%81%AF/1.png" alt="image-20220703122856297"></p><h1 id="OC中调用方法的内部原理是怎样的？"><a href="#OC中调用方法的内部原理是怎样的？" class="headerlink" title="OC中调用方法的内部原理是怎样的？"></a>OC中调用方法的内部原理是怎样的？</h1><ul><li><p>现有这样一个方法，p1是Person类的对象，sayHi是其实例方法</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[p1 sayHi]</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><ol><li>获取到 sayHi 这一消息的 SEL 对象</li><li>将这个SEL消息发送给p1对象，此时，p1对象接收到这个SEL消息以后 就知道要调用方法</li><li>根据p1对象的isa指针寻找存储类Person（Class对象）</li><li>找到这个类（Class对象）以后 在其中去搜寻是否有和传入的SEL数据相匹配的方法</li><li>如果有 就执行  如果没有再向父类寻找 直到NSObject类，若都没有匹配的方法，则抛出异常</li></ol><h1 id="OC的重要机制-消息机制"><a href="#OC的重要机制-消息机制" class="headerlink" title="OC的重要机制:消息机制"></a>OC的重要机制:消息机制</h1><ul><li>调用方法的本质其实就是向对象发送SEL消息.</li><li>[p1 sayHi]; 向p1对象发送1条sayHi消息.</li><li>重点掌握:<br>1).方法是以SEL对象的形式存储起来.<br>2).如何拿到存储方法的SEL对象：Class 对象获取</li></ul><h1 id="SEL消息的其他用法？"><a href="#SEL消息的其他用法？" class="headerlink" title="SEL消息的其他用法？"></a>SEL消息的其他用法？</h1><h2 id="手动发送消息"><a href="#手动发送消息" class="headerlink" title="手动发送消息"></a>手动发送消息</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">调用对象的方法 将SEL数据发送给对象.<br>- <span class="hljs-params">(id)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Person *p1 = [Person <span class="hljs-keyword">new</span>];<br><span class="hljs-type">SEL</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-meta">@selector(sayHi)</span>; <span class="hljs-comment">//先得到方法的SEL数据.</span><br>[p1 performSelector:s1];  <span class="hljs-comment">// 将这个SEL消息发送给p1对象，与 [p1 sayHi]效果是完全一样的.</span><br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h1><ol><li>使用 SEL 对象时，如果方法有参数 那么方法名是带了冒号的 <ol><li>@selector(sayHi:);</li></ol></li><li>如果方法有参数就调用如下方法:</li></ol><ul><li>(id)performSelector:(SEL)aSelector withObject:(id)object;</li><li>(id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</li></ul><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol><li><p>类是以Class对象的形式存储在代码段.</p></li><li><p>如何取到存储类的类对象.</p></li><li><p>如何使用类对象调用类的类方法 </p></li><li><p>方法是以SEL数据的形式存储的.</p></li><li><p>调用方法的两种方式.</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-4-语言特性-getter-setter</title>
    <link href="/2022/07/04/Objective-C-4-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-getter-setter/"/>
    <url>/2022/07/04/Objective-C-4-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-getter-setter/</url>
    
    <content type="html"><![CDATA[<h1 id="OC中是如何访问对象的属性的"><a href="#OC中是如何访问对象的属性的" class="headerlink" title="OC中是如何访问对象的属性的?"></a>OC中是如何访问对象的属性的?</h1><ul><li><p>OC中可以使用点语法来访问对象的属性</p></li><li><p>语法如下所示:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//对象名.去掉下划线的属性名;<br>p1.name = @&quot;jack&quot;; //这个时候就会将@&quot;jack&quot;赋值给p1对象的_name属性.<br>NSString *name = p1.name; //把p1对象的_name属性的值取出来<br></code></pre></td></tr></table></figure><ul><li>但,OC的对象如果要为属性赋值或者取值 就要调用对应的getter或者setter.</li></ul><h1 id="点语法实际是如何进行的"><a href="#点语法实际是如何进行的" class="headerlink" title="点语法实际是如何进行的?"></a>点语法实际是如何进行的?</h1>   <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">p1.age</span> = <span class="hljs-number">18</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>点语法在编译器编译的时候.会将点语法转换为调用setter、getter的代码.</li></ul><h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作:"></a>赋值操作:</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">p1.age</span> = <span class="hljs-number">10</span><span class="hljs-comment">;//对象名.去掉下划线的属性名 = 数据; 转换为</span><br><span class="hljs-section">[p1 setAge:10]</span><span class="hljs-comment">; //  [对象名 set去掉下划线的属性名首字母大写:数据];</span><br></code></pre></td></tr></table></figure><h2 id="取值操作"><a href="#取值操作" class="headerlink" title="取值操作:"></a>取值操作:</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int age <span class="hljs-operator">=</span> p1.age<span class="hljs-comment">;//     对象名.去掉下划线的属性名; 转换为</span><br>int age <span class="hljs-operator">=</span> [p1 age]<span class="hljs-comment">;//    [对象名 去掉下划线的属性名];</span><br></code></pre></td></tr></table></figure><h1 id="点语法注意"><a href="#点语法注意" class="headerlink" title="点语法注意:"></a>点语法注意:</h1><ul><li><p>在getter和setter中慎用点语法,因为有可能会造成无限递归 而程序崩溃</p></li><li><p>setter方法和getter方法名不符合规范 点语法就会出问题.</p></li><li><p>如果属性没有封装getter setter 是无法使用点语法的</p></li></ul><h1 id="property关键字是什么"><a href="#property关键字是什么" class="headerlink" title="@property关键字是什么?"></a>@property关键字是什么?</h1><ul><li><p>为了简化类属性 getter&#x2F;setter的声明代码,用于 <strong>自动生成类属性的getter、setter方法的声明</strong> 的关键字</p></li><li><p>会额外为类生成属性,并不会影响原来类已有的属性</p></li><li><p>因为是生成方法的声明,所以应该写在@interface类的声明之中.</p></li><li><p>语法: @property 数据类型 名称;</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@<span class="hljs-keyword">property</span> <span class="hljs-built_in">int</span> age; <br></code></pre></td></tr></table></figure><h1 id="property的原理是怎样的"><a href="#property的原理是怎样的" class="headerlink" title="@property的原理是怎样的?"></a>@property的原理是怎样的?</h1><ul><li>编译器在编译的时候.会根据@property生成getter和setter方法的实现</li></ul> <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@<span class="hljs-keyword">property</span> <span class="hljs-built_in">int</span> age; <span class="hljs-comment">//@property 数据类型 名称;</span><br>- (<span class="hljs-built_in">void</span>)setAge:(<span class="hljs-built_in">int</span>)age;<span class="hljs-comment">//- (void)set首字母大写的名称:(数据类型)名称;</span><br>- (<span class="hljs-built_in">int</span>)age;<span class="hljs-comment">//- (数据类型)名称;</span><br></code></pre></td></tr></table></figure><h1 id="property注意"><a href="#property注意" class="headerlink" title="@property注意:"></a>@property注意:</h1><ul><li><p><strong>@property的类型</strong>和<strong>属性的类型</strong>一致.</p></li><li><p><strong>@property的名称</strong>和<strong>属性的名称</strong>一致(去掉下划线)</p></li><li><p>@property只是生成getter和setter方法的声明. 实现还要自己来. 属性还要自己定义.</p></li></ul><h1 id="synthesize关键字是什么"><a href="#synthesize关键字是什么" class="headerlink" title="@synthesize关键字是什么?"></a>@synthesize关键字是什么?</h1><ul><li><p>为了简化类属性 getter&#x2F;setter的实现代码,用于 <strong>自动生成类的getter、setter方法的实现</strong> 的关键字</p></li><li><p>因为是生成方法的实现,所以应该写在@implement类的实现之中.</p></li><li><p>语法如下所示:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//--------Person.h<br>@interface Person : NSObject<br>&#123;<br>   int _age;<br>&#125;<br>@property int age;//age 的 getter,setter 声明<br>@end<br><br>//--------Person.m<br>@implmentation Person<br>@synthesize age; //age 的 getter,setter 实现 ;@synthesize @property名称;<br>@end<br><br><br></code></pre></td></tr></table></figure><h1 id="synthesize的原理是怎样的"><a href="#synthesize的原理是怎样的" class="headerlink" title="@synthesize的原理是怎样的?"></a>@synthesize的原理是怎样的?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@implmentation Person<br>  @synthesize age;<br>@end<br>//----------上述代码等同于如下代码:<br>@implementaion Person<br>&#123;<br>  int age;<br>&#125;<br>- (void)setAge:(int)age<br>&#123;<br>  self-&gt;age = age;<br>&#125;<br>- (int)age<br>&#123;<br>  return age;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><h1 id="synthesize做什么工作呢"><a href="#synthesize做什么工作呢" class="headerlink" title="@synthesize做什么工作呢?"></a>@synthesize做什么工作呢?</h1><h2 id="会自动生成的完全私有属性"><a href="#会自动生成的完全私有属性" class="headerlink" title="会自动生成的完全私有属性:"></a>会自动生成的完全私有属性:</h2><ul><li>如下写法会在这一类中自动生成一个完全私有的属性,以及这个属性的 getter 和 setter</li><li>自动生成的属性与外部其他属性无关</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>类的实现部分<br>@synthesize name;<span class="hljs-regexp">//</span>@synthesize 属性名称;<br></code></pre></td></tr></table></figure><ul><li>属性的类型应和@synthesize对应的@property类型或属性声明一致.</li><li>属性的名字应和@synthesize对应的@property名字或属性声明一致.</li></ul><h2 id="自动生成setter方法的实现"><a href="#自动生成setter方法的实现" class="headerlink" title="自动生成setter方法的实现:"></a>自动生成setter方法的实现:</h2><ul><li>实现的方式: 将参数直接赋值给**@synthesize自动生成的私有属性**.并且<strong>不会做任何额外操作</strong>,也不会对其他属性有影响</li></ul><h2 id="自动生成getter方法的实现"><a href="#自动生成getter方法的实现" class="headerlink" title="自动生成getter方法的实现."></a>自动生成getter方法的实现.</h2><ul><li>实现的方式: 直接将**@synthesize自动生成的私有属性的值**返回</li></ul><h1 id="如果属性被写好了-如何使用-synthesize自动生成-getter-和-setter"><a href="#如果属性被写好了-如何使用-synthesize自动生成-getter-和-setter" class="headerlink" title="如果属性被写好了,如何使用@synthesize自动生成 getter 和 setter?"></a>如果属性被写好了,如何使用@synthesize自动生成 getter 和 setter?</h1><ul><li>可以使用如下写法来实现:</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@synthesize</span> age = _age; <span class="hljs-regexp">//</span><span class="hljs-variable">@synthesize</span> 属性(<span class="hljs-variable">@property</span> 的)名称 = 已经存在的属性名;<br></code></pre></td></tr></table></figure><ul><li>这种写法的特点:<ul><li>不会再去生成私有属性.</li><li>直接生成setter getter的实现,且操作的是指定的属性</li></ul></li></ul><h1 id="如何向-synthesize自动生成的getter-和-setter中添加新逻辑"><a href="#如何向-synthesize自动生成的getter-和-setter中添加新逻辑" class="headerlink" title="如何向@synthesize自动生成的getter 和 setter中添加新逻辑?"></a>如何向@synthesize自动生成的getter 和 setter中添加新逻辑?</h1><ul><li><p>@synthesize生成的setter方法实现中 是没有做任何逻辑验证的 是直接赋值.</p></li><li><p>@synthesize生成的getter方法的实现中 是直接返回属性的值.</p></li><li><p>如果setter或者getter有自己的逻辑验证 那么就自己在类的实现中重写就可以了.</p></li></ul><h1 id="当类中有较多属性时-如何简便的向类中添加多个属性的声明及实现"><a href="#当类中有较多属性时-如何简便的向类中添加多个属性的声明及实现" class="headerlink" title="当类中有较多属性时,如何简便的向类中添加多个属性的声明及实现?"></a>当类中有较多属性时,如何简便的向类中添加多个属性的声明及实现?</h1><ul><li>@property只是生成getter setter 的声明</li><li>@synthesize是生成getter setter 的实现</li></ul><h2 id="声明多个类型一致的-property"><a href="#声明多个类型一致的-property" class="headerlink" title="声明多个类型一致的@property"></a>声明多个类型一致的@property</h2> <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@property</span> float <span class="hljs-attribute">height</span>,weight;<br></code></pre></td></tr></table></figure><h2 id="声明多个-synthesize"><a href="#声明多个-synthesize" class="headerlink" title="声明多个@synthesize"></a>声明多个@synthesize</h2><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">@synthesize <span class="hljs-built_in">name</span> = <span class="hljs-variable">_name</span>,age = <span class="hljs-variable">_age</span>,weight = <span class="hljs-variable">_weight</span>,height = <span class="hljs-variable">_height</span>;<br></code></pre></td></tr></table></figure><h1 id="新版本的-property"><a href="#新版本的-property" class="headerlink" title="新版本的@property"></a>新版本的@property</h1><ul><li>Xcode4.4以后,Xcode对@property做了1个增强,只需@property关键字,编译器就会自动生成一个 OC 类中的一个属性</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">@<span class="hljs-keyword">property</span><span class="hljs-title"> </span>NSString *name;<br></code></pre></td></tr></table></figure><h2 id="新版本-porperty-都做了哪些事情"><a href="#新版本-porperty-都做了哪些事情" class="headerlink" title="新版本@porperty 都做了哪些事情?"></a>新版本@porperty 都做了哪些事情?</h2><ol><li>自动的为类生成1个私有属性</li><li>属性的类型和@property类型一致 </li><li>属性的名称和@property的名称一致 并自动为这个属性的名称添加1个下划线.</li><li>自动的生成这个属性的getter setter方法的声明以及实现<ol><li>setter的实现: 直接将参数的值赋值给自动生成的私有属性.</li><li>getter的实现: 直接返回生成的私有属性的值.</li></ol></li></ol><h1 id="新版本-porperty的注意要点有哪些"><a href="#新版本-porperty的注意要点有哪些" class="headerlink" title="新版本@porperty的注意要点有哪些?"></a>新版本@porperty的注意要点有哪些?</h1><ul><li><p>@property的类型对应类成员属性类型</p></li><li><p>@property的名称对应类成员属性的去掉下划线后的属性名</p></li><li><p>新版本的@property也支持相同类型的批量声明</p></li><li><p>新版本的@property生成的方法实现也没有做任何逻辑验证</p></li><li><p>自定义验证逻辑时</p><ul><li>如果重写了setter 还会自动生成getter</li><li>如果重写了getter 还会自动生成setter </li><li>如果同时重写getter setter 那么就不会自动生成私有属性了,需要手动向类中添加属性</li></ul></li><li><p>父类的@property一样可以被子类继承</p></li><li><p>@property生成的属性是私有的 在子类的内部无法直接访问,但可通过setter getter来访问    </p></li><li><p>生成的setter方法的实现中,无论是什么类型的,都是直接赋值</p><ul><li>若设定为 MRC 时,setter 和 dealloc 方法中对对象的复制与释放的都需要手动完成</li></ul></li></ul><h1 id="新版本-property中参数有哪些"><a href="#新版本-property中参数有哪些" class="headerlink" title="新版本@property中参数有哪些?"></a>新版本@property中参数有哪些?</h1><ul><li><p>语法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span>(atomic,<span class="hljs-keyword">assign</span>,<span class="hljs-keyword">readwrite</span>,<span class="hljs-keyword">getter</span> = <span class="hljs-keyword">getter</span>方法名字,<span class="hljs-keyword">setter</span> = <span class="hljs-keyword">setter</span>方法名字:)数据类型 名称;<br></code></pre></td></tr></table></figure></li><li><p>按照使用功能来划分,@property有四组参数:</p></li></ul><h2 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h2><pre><code class="hljs"> ### atomic</code></pre><ul><li>默认值</li><li>如果写atomic,这个时候生成的setter方法的代码就会被加上一把线程安全锁.</li><li>特点: 安全、效率低下.</li></ul><h3 id="nonatomic"><a href="#nonatomic" class="headerlink" title="nonatomic"></a>nonatomic</h3><ul><li><p>如果写nonatomic 这个时候生成的setter方法的代码就不会加线程安全锁.</p></li><li><p>特点: 不安全,但是效率高.</p><p> 建议: 要效率. 选择使用nonatomic 在没有讲解多线程的知识以前 统统使用nonatomic</p></li></ul><h2 id="生成的setter方法的实现相关"><a href="#生成的setter方法的实现相关" class="headerlink" title="生成的setter方法的实现相关"></a>生成的setter方法的实现相关</h2><h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><ul><li>默认值 </li><li>生成的setter方法的实现就是直接赋值</li><li>当属性的类型是非OC对象的时候,使用assign</li></ul><h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><ul><li>生成的setter方法的实现就是标准的MRC内存管理代码<ul><li>先判断新旧对象是否为同1个对象 如果不是 release旧的  retain新的</li><li>仍需要手动的在dealloc中release</li></ul></li><li>当属性的类型是OC对象类型的时候,那么就使用retain</li></ul><h2 id="生成只读、读写的属性相关"><a href="#生成只读、读写的属性相关" class="headerlink" title="生成只读、读写的属性相关"></a>生成只读、读写的属性相关</h2><h3 id="readwrite"><a href="#readwrite" class="headerlink" title="readwrite"></a>readwrite</h3><ul><li>默认值</li><li>代表同时生成getter setter</li></ul><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><ul><li>只会生成getter 不会生成setter</li></ul><h2 id="生成的getter-setter方法名字相关"><a href="#生成的getter-setter方法名字相关" class="headerlink" title="生成的getter setter方法名字相关"></a>生成的getter setter方法名字相关</h2><ul><li>通过@property生成的getter setter方法名都是符合标准的<ul><li>但也可通过参数来指定@property生成的方法名</li></ul></li><li>使用getter setter修改了生成的方法名,使用点语法时,编译器会展示修改后的方法名</li></ul><h3 id="getter-x3D-getter方法名字"><a href="#getter-x3D-getter方法名字" class="headerlink" title="(getter &#x3D; getter方法名字)"></a>(getter &#x3D; getter方法名字)</h3><ul><li>用来指定@property生成的getter方法的名字</li></ul><h4 id="何时修改getter方法名"><a href="#何时修改getter方法名" class="headerlink" title="何时修改getter方法名?"></a>何时修改getter方法名?</h4><ul><li>当属性为BOOL类型时,就修改getter的方法名以is开头 提高代码的阅读性.</li></ul><h3 id="setter-x3D-setter方法名字"><a href="#setter-x3D-setter方法名字" class="headerlink" title="(setter &#x3D; setter方法名字:)"></a>(setter &#x3D; setter方法名字:)</h3><ul><li><p>用来指定@property生成的setter方法的名字</p></li><li><p>setter方法是带参数的 所以要加1个冒号</p></li><li><p>一般无需修改setter方法的名字,默认情况下生成的名字就是标准方法名</p></li></ul><h1 id="当两个对象的属性值相互引用时-出现内存泄漏"><a href="#当两个对象的属性值相互引用时-出现内存泄漏" class="headerlink" title="当两个对象的属性值相互引用时,出现内存泄漏?"></a>当两个对象的属性值相互引用时,出现内存泄漏?</h1><ul><li>A对象中包含B类型属性b1; B对象中包含A类型属性a1;</li><li>此时,若这两个属性的@property 参数中均使用retain 那么就会发生内存泄露</li></ul><h2 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h2><ul><li>互相持有导致A,B 对象的引用计数在 release 时都没有变为 0,两个对象都 不会调用 dealloc 方法</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><ul><li>令A中的b1属性的@property 参数使用assign </li><li>A类中的dealloc中不需 release b1 对象</li><li>A:b1 可换为 B:a1</li></ul><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因:"></a>原因:</h3><ul><li>assign 是直接赋值,不进行 release,retain操作</li><li>在进行相互引用时,拥有 assign属性 的对象 A 的引用计数就只会+1</li><li>因此在两个对象被回收时,B 对象的引用计数一定先到 0,进而调用自己的 dealloc 函数,从而 release 掉 A</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><ul><li>如果你想为类写1个属性 并且为这个属性封装getter setter, 使用@property就搞定,不需要再使用@synthesize</li><li>对于一个属性的@property的参数;<ul><li>同组参数只能使用1个(getter&#x2F;setter 方法名除外)</li><li>参数的顺序可以随意</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-6-语言特性-构造方法</title>
    <link href="/2022/07/04/Objective-C-6-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/04/Objective-C-6-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="new-方法是什么"><a href="#new-方法是什么" class="headerlink" title="new 方法是什么?"></a>new 方法是什么?</h1><ul><li><p>用于创建对象</p></li><li><p>new实际上是1个类方法 其中进行的操作:</p><ul><li><p>创建对象:调用的alloc方法</p><ul><li>alloc 方法:分配空间并创建对应类的对象</li></ul></li><li><p>初始化对象:调用的init方法</p></li><li><p>返回对象地址</p></li></ul></li><li><p>使用未经初始化的对象是极其危险的.千万不要这么做.</p></li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">Person *p1 = [Person new]; //  类名 *指针名 = [类名 new];<br>//完全等价于<br>Person *p1 = [[Person alloc] init];<br></code></pre></td></tr></table></figure><h1 id="init方法是什么"><a href="#init方法是什么" class="headerlink" title="init方法是什么?"></a>init方法是什么?</h1><ul><li>作用: 初始化对象,为对象的属性赋初始值&#x2F;默认值</li><li>init方法也被叫做构造方法,在调用 new 方法创建对象时会自动调用对应类的构造方法<ul><li>即使创建对象时没有为属性赋值,这些属性都会被设置为默认值</li></ul></li><li>属性的类型是:<ul><li>基本数据类型,赋值为0</li><li>C指针,赋值为NULL</li><li>OC指针,赋值为nil</li></ul></li></ul><h1 id="如何让创建的对象默认值不是-0-或-nil"><a href="#如何让创建的对象默认值不是-0-或-nil" class="headerlink" title="如何让创建的对象默认值不是 0 或 nil ?"></a>如何让创建的对象默认值不是 0 或 nil ?</h1><ul><li>重写init方法.并为对象的对应属性赋值</li><li>每次调用 new 方法创建的对象都会使用 init 中的赋值</li></ul><h2 id="重写init方法的规范"><a href="#重写init方法的规范" class="headerlink" title="重写init方法的规范"></a>重写init方法的规范</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (instancetype)init<br>&#123;<br>    if(self = [super init])<br>      //先调用父类的init方法,并判断父类(对应属性)是否初始化成功<br>      //调用init方法 初始化失败会返回 nil<br>    &#123;<br>       //当前对象属性赋值<br>    &#125;<br>    return self; //最后 返回self的值<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么要调用父类的init方法"><a href="#为什么要调用父类的init方法" class="headerlink" title="为什么要调用父类的init方法?"></a>为什么要调用父类的init方法?</h2><ul><li>因为父类的init方法 会初始化父类的属性,必须要保证当前对象中的父类属性也同时被初始化.</li></ul><h2 id="为什么要赋值给self？"><a href="#为什么要赋值给self？" class="headerlink" title="为什么要赋值给self？"></a>为什么要赋值给self？</h2><ul><li>因为 调用父类的init方法 会返回初始化成功的父类属性的对象</li><li>实际上返回的就是当前对象。但是我们要判断是否初始化成功.</li></ul><h1 id="如何通过-init-方法创建属性值不同的对象"><a href="#如何通过-init-方法创建属性值不同的对象" class="headerlink" title="如何通过 init 方法创建属性值不同的对象?"></a>如何通过 init 方法创建属性值不同的对象?</h1><ul><li><p>重写init方法后,每次创建出来的对象的属性的值都是一样的</p></li><li><p>创建对象的时候,对象的属性的值不应写死在init方法中</p></li><li><p>使用自定义构造方法创建对象</p></li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (instancetype)initWithName:(NSString *)name andAge:(int)age<br>&#123;<br>    if(self = [super init])<br>    &#123;<br>        self.name = name;<br>        self.age = age;<br>    &#125;<br>    return self;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义构造方法注意"><a href="#自定义构造方法注意" class="headerlink" title="自定义构造方法注意:"></a>自定义构造方法注意:</h2><ol><li>自定义构造方法的返回值必须是instancetype</li><li>自定义构造方法的名称必须以initWith开头</li><li>方法的实现和init的要求一样</li><li>调用自定义的构造方法时,不应直接使用 new,应先alloc 再调用自定义的initWith</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C-1-概述</title>
    <link href="/2022/07/04/Objective-C-1-%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/07/04/Objective-C-1-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要学习-Objective-C？"><a href="#为什么要学习-Objective-C？" class="headerlink" title="为什么要学习 Objective-C？"></a>为什么要学习 Objective-C？</h1><ul><li><p>OC,是在 Swift 诞生以前 IOS、MacOS 开发的主要编程语言</p></li><li><p>一些项目随着苹果的更新或多或少都使用了 OC 与 Swift 混编</p></li></ul><p><img src="/./Objective-C-1-%E6%A6%82%E8%BF%B0/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE.png" alt="学习路线图"></p><h1 id="OC和C语言有何种关系？"><a href="#OC和C语言有何种关系？" class="headerlink" title="OC和C语言有何种关系？"></a>OC和C语言有何种关系？</h1><ul><li>OC 是NextStep 公司对C语言进行一层封装后形成的新语言</li><li>在 C语言的基础上增加了面向对象思想</li><li>一些语法封装</li><li>OC 完全兼容 C 语言</li></ul><h1 id="OC是如何写出HelloWorld的？"><a href="#OC是如何写出HelloWorld的？" class="headerlink" title="OC是如何写出HelloWorld的？"></a>OC是如何写出HelloWorld的？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//<br>//  main.m  <br>//  项目名<br>//<br>//  Created by tiger on 2022/7/1.<br>//  Copyright © 2022 itcast. All rights reserved.<br>#import &lt;Foundation/Foundation.h&gt;<br>int main(int argc, const char * argv[]) &#123; <br>    @autoreleasepool &#123;<br>        // insert code here...<br>        NSLog(@&quot;Hello, World!&quot;);<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="HelloWorld-m中有哪些要点？"><a href="#HelloWorld-m中有哪些要点？" class="headerlink" title="HelloWorld.m中有哪些要点？"></a>HelloWorld.m中有哪些要点？</h1><h2 id="后缀名"><a href="#后缀名" class="headerlink" title="后缀名"></a>后缀名</h2><ul><li>OC程序的源文件的后缀名是.m  m代表message 消息，代表OC中 消息机制</li></ul><h2 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h2><ul><li><p>以#号开头，是预处理指令，同1个文件只要#import过,只会包含1份</p></li><li><p>作用: 将文件的内容在预编译的时候拷贝写指令的地方</p></li><li><p>原理: #import指令在包含文件的时候,底层会先判断这个文件是否被包含  如果被包含就会略过 否则才会包含</p></li><li><p>C语言中，如果#include指令要实现这个效果 就必须要配合条件编译指令来实现</p></li></ul><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><ul><li><p>是OC程序的入口和出口                                         &amp;#x20;</p></li><li><p>返回值 int类型 代表程序的结束状态  </p><ul><li>0 代表正常结束 非0代表非正常结束.         &amp;#x20;</li></ul></li><li><p>参数: 命令行运行时，可接收运行时用户入参 也可以无参数&amp;#x20;</p><ul><li>argc代表用户传递的数据的个数.</li><li>argv数组中每个元素存储的就是用户传递过来的数据.</li></ul></li></ul><h2 id="Foundation-x2F-Foundation-h"><a href="#Foundation-x2F-Foundation-h" class="headerlink" title="Foundation&#x2F;Foundation.h"></a>Foundation&#x2F;Foundation.h</h2><ul><li>main 函数中引用了 Foundation框架中的 Foundation.h头文件<ul><li>Foundation.h 中包含了Foundation框架中的其他的所有的头文件</li><li>Foundation.h位于如下路径：<ul><li>&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX10.10.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Foundation.framework&#x2F;Versions&#x2F;C&#x2F;Headers&#x2F;Foundation.h</li></ul></li></ul></li></ul><h2 id="autoreleasepool：自动释放池"><a href="#autoreleasepool：自动释放池" class="headerlink" title="@autoreleasepool：自动释放池"></a>@autoreleasepool：自动释放池</h2><p>- </p><h2 id="NSLog函数"><a href="#NSLog函数" class="headerlink" title="NSLog函数"></a>NSLog函数</h2><ul><li>向控制台输出信息</li><li><code> NSLog(@&quot;格式控制字符串&quot;,变量列表);</code></li></ul><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li><p>输出一些调试相关信息.</p><pre><code class="hljs"><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">2020-07-01</span> <span class="hljs-number">12</span>:<span class="hljs-number">40:52.628</span> Day01-OC基础语法[<span class="hljs-number">784:210576</span>] Hello,World!<br>执行时间                   程序的名称    [进程编号:线程编号]  输出的信息. <br></code></pre></td></tr></table></figure></code></pre></li><li><p>会自动换行 但手动在字符串结尾使用 ‘ \n ’ 则不会自动换行</p></li></ul><h1 id="OC-中如何使用字符串？"><a href="#OC-中如何使用字符串？" class="headerlink" title="OC 中如何使用字符串？"></a>OC 中如何使用字符串？</h1><ul><li><p>在OC中专门设计了1个NSString类型来存储字符串</p></li><li><p>字符串分为C字符串和OC字符串</p><ul><li>“jack” 这是1个C语言的字符串.</li><li>@”jack” 这是1个OC的字符串常量.</li></ul></li><li><p>OC中使用 NSString类型的指针 存储字符串的地址.</p></li><li><p>OC中，字符串常量必须要使用1个前缀@符号.</p></li><li><p>NSLog函数的第1个参数是1个OC字符串,所以NSLog函数的第1个实参应该以@符号开头.</p></li><li><p>如果要使用NSLog函数输出OC字符串的值,那么使用占位符%@</p></li></ul><h1 id="OC-中的NS前缀是什么意思？"><a href="#OC-中的NS前缀是什么意思？" class="headerlink" title="OC 中的NS前缀是什么意思？"></a>OC 中的NS前缀是什么意思？</h1><ul><li>NextStep公司开发 OC —&gt; 公司更名为Cocoa —&gt; Foundation框架之中</li></ul><h1 id="OC-中的-前缀是什么意思？"><a href="#OC-中的-前缀是什么意思？" class="headerlink" title="OC 中的@前缀是什么意思？"></a>OC 中的@前缀是什么意思？</h1><ul><li><p>将C字符串转换为OC字符串.</p></li><li><p>OC中的绝大部分的关键字都是以@符号开头.</p></li></ul><h1 id="OC中的注释？"><a href="#OC中的注释？" class="headerlink" title="OC中的注释？"></a>OC中的注释？</h1><ul><li>和C语言的注释一模一样.分为单行注释和多行注释.</li></ul><h1 id="OC程序是如何运行的？"><a href="#OC程序是如何运行的？" class="headerlink" title="OC程序是如何运行的？"></a>OC程序是如何运行的？</h1><ul><li>程序从代码到可执行文件的三个阶段：  预处理、检查语法、编译、连接、执行</li><li>点击运行按钮 所有的事情Xcode就帮助我们自动的做了</li></ul><h2 id="编译：使用编译器将源代码编译为目标文件"><a href="#编译：使用编译器将源代码编译为目标文件" class="headerlink" title="编译：使用编译器将源代码编译为目标文件"></a>编译：使用编译器将源代码编译为目标文件</h2><p> 终端中编译某一.m文件的命令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> xx.m<br></code></pre></td></tr></table></figure><ul><li>编译.m后会生成中间文件.o</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">cc</span> xx.o -framework 框架名称<br></code></pre></td></tr></table></figure><ul><li><p>如果程序中使用到了框架中的函数或者类.那么在链接的时候,就必须要告诉编译器去哪个框架中找这个函数或者类.</p></li><li><p>链接成功以后 就会生成1个a.out可执行文件 执行就可以了.</p></li></ul><h1 id="OC中都有哪些数据类型？"><a href="#OC中都有哪些数据类型？" class="headerlink" title="OC中都有哪些数据类型？"></a>OC中都有哪些数据类型？</h1><ul><li><p>支持C语言中的所有的数据类型.</p><ul><li><p>基本数据类型：int double float char</p></li><li><p>构造类型：数组 结构体 枚举</p></li><li><p>指针类型： int *p1;</p></li><li><p>空类型：void</p></li><li><p>typedef 自定义类型</p></li></ul></li><li><p>新类型：</p><ul><li><p>BOOL类型：YES或者NO</p><ul><li><p>本质：有符号的char变量</p><ul><li><p>typedef signed char BOOL; </p></li><li><p>#define YES ((BOOL)1）</p></li><li><p>#define NO ((BOOL)0)</p></li></ul></li></ul></li><li><p>Boolean</p><ul><li><p>可以存储true或者flase</p></li><li><p>本质：无符号的char变量</p><ul><li>typedef unsigned char     Boolean;</li><li>#define true 1</li><li>#define false 0</li></ul></li></ul></li><li><p>class 类型 类</p></li><li><p>id类型 万能指针</p></li><li><p>nil 与NULL差不多</p></li><li><p>SEL 方法选择器</p></li><li><p>block 代码段</p></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>OC 是什么，和 C语言关系</li><li>分析 HelloWorld</li><li>OC 程序是如何运行的</li><li>OC 中的数据类型</li></ol>]]></content>
    
    
    <categories>
      
      <category>Objective-C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言基础</tag>
      
      <tag>iOS/MacOS</tag>
      
      <tag>概述</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
